<!DOCTYPE html>
<html>
<head>
    <title>Heart Pong Game - Corrected Version</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
            height: 100vh;
            width: 100vw;
            cursor: none;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #000;
            z-index: 5;
        }
        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 2vh;
            user-select: none;
            z-index: 10;
        }
        #startButton, #restartButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
        }
        #startButton:hover, #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
        }
        /* Media Query for Mobile Devices */
        @media only screen and (max-width: 768px) {
            #scoreboard {
                font-size: 1vh;
            }
            #gameOver {
                font-size: 3vh;
            }
            #startButton, #restartButton {
                font-size: 1rem;
                padding: 10px 20px;
            }
        }
    </style>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Scoreboard -->
    <div id="scoreboard">Score: 0<br>Misses Left: 3</div>
    <!-- Game Over and Buttons -->
    <div id="gameOver">GAME OVER</div>
    <div id="startButton" onclick="startGame()">START GAME</div>
    <div id="restartButton" onclick="restartGame()" style="display: none;">RESTART</div>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game variables
        let heartPath = new Path2D();
        let paddleIndex = 0;
        const paddleLength = 50; // Number of points that make up the paddle
        const paddleSpeed = 5; // Paddle movement speed
        let score = 0;
        let misses = 0;
        const maxMisses = 3;
        let gameStarted = false;
        let gameOver = false;
        let animationFrameId;

        // Ball properties
        let ball = {
            x: 0,
            y: 0,
            radius: 8,
            speed: 3, // Slower initial speed
            angle: Math.PI / 4 // 45 degrees
        };

        // Heart shape points
        let heartPoints = [];

        // Mouse and touch controls
        let pointerPosition = { x: canvas.width / 2, y: canvas.height / 2 };

        canvas.addEventListener('mousemove', function (e) {
            pointerPosition.x = e.clientX;
            pointerPosition.y = e.clientY;
            if (gameStarted && !gameOver) {
                updatePaddleIndex();
            }
        });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            pointerPosition.x = e.touches[0].clientX;
            pointerPosition.y = e.touches[0].clientY;
            if (gameStarted && !gameOver) {
                updatePaddleIndex();
            }
        }, { passive: false });

        // Resize canvas to fit the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateHeartPoints(); // Regenerate heart points to fit new size
            if (!gameStarted) {
                setBallStartingPosition();
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // Generate heart shape points
        function generateHeartPoints() {
            heartPoints = [];
            for (let t = 0; t < 2 * Math.PI; t += 0.01) {
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                heartPoints.push({ x: x, y: -y });
            }

            // Scale and center the heart
            const scale = Math.min(canvas.width, canvas.height) / 40;
            heartPoints = heartPoints.map(point => ({
                x: point.x * scale + canvas.width / 2,
                y: point.y * scale + canvas.height / 2
            }));

            // Create the heart path for collision detection
            heartPath = new Path2D();
            heartPath.moveTo(heartPoints[0].x, heartPoints[0].y);
            for (let i = 1; i < heartPoints.length; i++) {
                heartPath.lineTo(heartPoints[i].x, heartPoints[i].y);
            }
            heartPath.closePath();
        }

        // Set ball starting position inside the heart
        function setBallStartingPosition() {
            // Start at the center of the heart
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;

            // If the center is not inside the heart, adjust position
            if (!ctx.isPointInPath(heartPath, ball.x, ball.y)) {
                for (let point of heartPoints) {
                    if (ctx.isPointInPath(heartPath, point.x, point.y)) {
                        ball.x = point.x;
                        ball.y = point.y;
                        break;
                    }
                }
            }
        }

        // Draw heart outline
        function drawHeart() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke(heartPath);
        }

        // Draw paddle
        function drawPaddle() {
            ctx.beginPath();
            ctx.strokeStyle = 'magenta';
            ctx.lineWidth = 5;
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'magenta';
            let startIndex = paddleIndex;
            let endIndex = (paddleIndex + paddleLength) % heartPoints.length;
            ctx.moveTo(heartPoints[startIndex].x, heartPoints[startIndex].y);

            if (endIndex > startIndex) {
                for (let i = startIndex + 1; i <= endIndex; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
            } else {
                for (let i = startIndex + 1; i < heartPoints.length; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
                for (let i = 0; i <= endIndex; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
            }

            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Update paddle index based on pointer position
        function updatePaddleIndex() {
            let minDistance = Infinity;
            for (let i = 0; i < heartPoints.length; i++) {
                let dx = pointerPosition.x - heartPoints[i].x;
                let dy = pointerPosition.y - heartPoints[i].y;
                let distance = dx * dx + dy * dy;
                if (distance < minDistance) {
                    minDistance = distance;
                    paddleIndex = i;
                }
            }
        }

        // Update ball position and handle collisions
        function updateBall() {
            let dx = ball.speed * Math.cos(ball.angle);
            let dy = ball.speed * Math.sin(ball.angle);

            ball.x += dx;
            ball.y += dy;

            // Check collision with heart boundary
            if (!ctx.isPointInPath(heartPath, ball.x, ball.y)) {
                // Find nearest point on heart boundary
                let minDistance = Infinity;
                let nearestPoint = null;
                for (let point of heartPoints) {
                    let distance = Math.hypot(ball.x - point.x, ball.y - point.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPoint = point;
                    }
                }

                // Calculate normal at collision point
                let normalAngle = Math.atan2(ball.y - nearestPoint.y, ball.x - nearestPoint.x);
                ball.angle = reflectAngle(ball.angle, normalAngle);

                // Increase miss count
                misses++;
                updateScoreboard();

                // Check for game over
                if (misses >= maxMisses) {
                    endGame();
                }

                // Move ball slightly inside the heart to prevent sticking
                ball.x += 2 * Math.cos(ball.angle);
                ball.y += 2 * Math.sin(ball.angle);
            }

            // Check collision with paddle
            if (isBallCollidingWithPaddle()) {
                // Calculate normal at collision point
                let normalAngle = getPaddleNormalAngle();
                ball.angle = reflectAngle(ball.angle, normalAngle);

                // Increase score
                score++;
                updateScoreboard();

                // Move ball slightly away from paddle to prevent sticking
                ball.x += 2 * Math.cos(ball.angle);
                ball.y += 2 * Math.sin(ball.angle);
            }
        }

        // Reflect angle based on normal
        function reflectAngle(incidentAngle, normalAngle) {
            return (2 * normalAngle - incidentAngle + Math.PI) % (2 * Math.PI);
        }

        // Check if ball is colliding with paddle
        function isBallCollidingWithPaddle() {
            let indices = [];
            let startIndex = paddleIndex;
            let endIndex = (paddleIndex + paddleLength) % heartPoints.length;

            if (endIndex > startIndex) {
                for (let i = startIndex; i <= endIndex; i++) {
                    indices.push(i);
                }
            } else {
                for (let i = startIndex; i < heartPoints.length; i++) {
                    indices.push(i);
                }
                for (let i = 0; i <= endIndex; i++) {
                    indices.push(i);
                }
            }

            for (let idx of indices) {
                let point = heartPoints[idx];
                let distance = Math.hypot(ball.x - point.x, ball.y - point.y);
                if (distance <= ball.radius + ctx.lineWidth / 2) {
                    return true;
                }
            }
            return false;
        }

        // Get normal angle at paddle collision point
        function getPaddleNormalAngle() {
            let idx = (paddleIndex + Math.floor(paddleLength / 2)) % heartPoints.length;
            let currentPoint = heartPoints[idx];
            let nextPoint = heartPoints[(idx + 1) % heartPoints.length];
            let angle = Math.atan2(nextPoint.y - currentPoint.y, nextPoint.x - currentPoint.x);
            return (angle + Math.PI / 2) % (2 * Math.PI);
        }

        // Draw ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'magenta';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'magenta';
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Update scoreboard
        function updateScoreboard() {
            document.getElementById('scoreboard').innerHTML = `Score: ${score}<br>Misses Left: ${maxMisses - misses}`;
        }

        // Main game loop
        function gameLoop() {
            if (gameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawHeart();
            drawPaddle();
            updateBall();
            drawBall();
            updateScoreboard();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Start the game
        function startGame() {
            // Hide start button
            document.getElementById('startButton').style.display = 'none';
            // Reset variables
            score = 0;
            misses = 0;
            gameStarted = true;
            gameOver = false;
            setBallStartingPosition();
            ball.angle = Math.PI / 4; // Reset ball angle
            updateScoreboard();
            // Start game loop
            gameLoop();
        }

        // End the game
        function endGame() {
            gameOver = true;
            // Cancel animation frame
            cancelAnimationFrame(animationFrameId);
            // Show game over and restart button
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('restartButton').style.display = 'block';
        }

        // Restart the game
        function restartGame() {
            // Hide game over and restart button
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            // Reset variables
            score = 0;
            misses = 0;
            gameStarted = true;
            gameOver = false;
            setBallStartingPosition();
            ball.angle = Math.PI / 4; // Reset ball angle
            updateScoreboard();
            // Start game loop
            gameLoop();
        }

        // Initialize game
        resizeCanvas();
        generateHeartPoints();
        setBallStartingPosition(); // Ensure ball starts inside the heart

        // Show start button
        document.getElementById('startButton').style.display = 'block';
    </script>
</body>
</html>

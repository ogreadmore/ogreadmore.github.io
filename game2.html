<!DOCTYPE html>
<html>
<head>
    <title>heart centered</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
            height: 100vh;
            width: 100vw;
            /* Cursor visibility handled via 'playing' class */
        }

        /* Hide cursor only when the game is playing */
        body.playing {
            cursor: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #000;
            z-index: 5;
        }

        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 2vh;
            user-select: none;
            z-index: 10;
            text-align: left;
        }

        #startButton, #restartButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
        }

        #startButton:hover, #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
        }

        /* Media Query for Mobile Devices */
        @media only screen and (max-width: 768px) {
            #scoreboard {
                font-size: 1vh;
            }
            #gameOver {
                font-size: 3vh;
            }
            #startButton, #restartButton {
                font-size: 1rem;
                padding: 10px 20px;
            }
        }
    </style>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Scoreboard -->
    <div id="scoreboard">
        <div>heart centered</div>
        <div>score: 0</div>
    </div>
    <!-- Game Over and Buttons -->
    <div id="gameOver">GAME OVER</div>
    <div id="startButton" onclick="startGame()">START GAME</div>
    <div id="restartButton" onclick="restartGame()" style="display: none;">RESTART</div>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game variables
        let heartPath = new Path2D();
        let heartPoints = [];
        const totalHeartPoints = 1000; // Increased for smoother heart
        let paddleStartIndex = 0;
        const paddleLength = 100; // Length of the paddle in number of points
        let score = 0;
        let gameStarted = false;
        let gameOver = false;
        let gameEnding = false; // Flag to manage game ending sequence
        let animationFrameId;

        // Ball properties
        let ball = {
            x: 0,
            y: 0,
            radius: 10, // Increased for better visibility
            speed: 3, // Reduced from 4 for slower starting speed
            velocity: { x: 0, y: 0 } // Velocity vector
        };

        // Mouse and touch controls
        let pointerPosition = { x: canvas.width / 2, y: canvas.height / 2 };

        // Keyboard controls
        let keyboardControl = { left: false, right: false };

        // Flag to track if the ball is currently outside the heart
        let isBallOutside = false;

        // Flag to track if the paddle was hit (for visual feedback)
        let isPaddleHit = false;

        // Event listeners for mouse
        canvas.addEventListener('mousemove', function (e) {
            pointerPosition.x = e.clientX;
            pointerPosition.y = e.clientY;
            if (gameStarted && !gameOver && !gameEnding) {
                updatePaddleIndex();
            }
        });

        // Event listeners for touch
        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            pointerPosition.x = e.touches[0].clientX;
            pointerPosition.y = e.touches[0].clientY;
            if (gameStarted && !gameOver && !gameEnding) {
                updatePaddleIndex();
            }
        }, { passive: false });

        // Event listeners for keyboard
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                keyboardControl.left = true;
            }
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                keyboardControl.right = true;
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                keyboardControl.left = false;
            }
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                keyboardControl.right = false;
            }
        });

        // Resize canvas to fit the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateHeartPoints(); // Regenerate heart points to fit new size
            if (!gameStarted) {
                setBallStartingPosition();
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // Generate heart shape points
        function generateHeartPoints() {
            heartPoints = [];
            for (let t = 0; t < 2 * Math.PI; t += (2 * Math.PI) / totalHeartPoints) {
                // Heart shape parametric equations
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                heartPoints.push({ x: x, y: -y }); // Invert y for canvas coordinates
            }

            // Scale and center the heart
            const scale = Math.min(canvas.width, canvas.height) / 40;
            heartPoints = heartPoints.map(point => ({
                x: point.x * scale + canvas.width / 2,
                y: point.y * scale + canvas.height / 2
            }));

            // Create the heart path for collision detection
            heartPath = new Path2D();
            heartPath.moveTo(heartPoints[0].x, heartPoints[0].y);
            for (let i = 1; i < heartPoints.length; i++) {
                heartPath.lineTo(heartPoints[i].x, heartPoints[i].y);
            }
            heartPath.closePath();
        }

        // Set ball starting position inside the heart
        function setBallStartingPosition() {
            // Start at the center of the heart
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;

            // Initialize velocity if not set
            if (!gameStarted) {
                initializeBallVelocity();
            }
        }

        // Initialize ball velocity with a random angle
        function initializeBallVelocity() {
            let angleDegrees = Math.random() * 120 + 30; // 30 to 150 degrees
            let angleRadians = angleDegrees * (Math.PI / 180);
            ball.velocity.x = ball.speed * Math.cos(angleRadians);
            ball.velocity.y = ball.speed * Math.sin(angleRadians);
        }

        // Reflect the ball's velocity vector based on the normal vector
        function reflectVelocity(incident, normal) {
            // Normalize the normal vector
            let normLength = Math.hypot(normal.x, normal.y);
            if (normLength === 0) return { x: incident.x, y: incident.y }; // Prevent division by zero
            let normalUnit = { x: normal.x / normLength, y: normal.y / normLength };

            // Compute dot product
            let dot = incident.x * normalUnit.x + incident.y * normalUnit.y;

            // Compute reflected vector
            let reflected = {
                x: incident.x - 2 * dot * normalUnit.x,
                y: incident.y - 2 * dot * normalUnit.y
            };

            return reflected;
        }

        // Draw heart outline with dotted line
        function drawHeart() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dotted line pattern
            ctx.stroke(heartPath);
            ctx.setLineDash([]); // Reset to solid for other drawings
        }

        // Draw paddle with increased thickness and consistent length
        function drawPaddle() {
            ctx.beginPath();
            ctx.strokeStyle = 'magenta';
            ctx.lineWidth = 25; // Increased for better visibility
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'magenta';
            let endIndex = (paddleStartIndex + paddleLength) % heartPoints.length;

            // Handle wrap-around
            if (paddleStartIndex < endIndex) {
                ctx.moveTo(heartPoints[paddleStartIndex].x, heartPoints[paddleStartIndex].y);
                for (let i = paddleStartIndex + 1; i <= endIndex; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
            } else {
                ctx.moveTo(heartPoints[paddleStartIndex].x, heartPoints[paddleStartIndex].y);
                for (let i = paddleStartIndex + 1; i < heartPoints.length; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
                for (let i = 0; i <= endIndex; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
            }

            ctx.stroke();

            // Add a brief glow effect if paddle was hit
            if (isPaddleHit) {
                ctx.beginPath();
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 30; // Slightly thicker for glow effect
                ctx.shadowBlur = 40;
                ctx.shadowColor = 'yellow';
                if (paddleStartIndex < endIndex) {
                    ctx.moveTo(heartPoints[paddleStartIndex].x, heartPoints[paddleStartIndex].y);
                    for (let i = paddleStartIndex + 1; i <= endIndex; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                } else {
                    ctx.moveTo(heartPoints[paddleStartIndex].x, heartPoints[paddleStartIndex].y);
                    for (let i = paddleStartIndex + 1; i < heartPoints.length; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                    for (let i = 0; i <= endIndex; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                }
                ctx.stroke();
                ctx.shadowBlur = 0; // Reset shadow
                isPaddleHit = false; // Reset the flag
            }

            ctx.shadowBlur = 0; // Reset shadow for other drawings
        }

        // Update paddle index based on pointer position
        function updatePaddleIndex() {
            let minDistance = Infinity;
            let newPaddleStart = paddleStartIndex;
            for (let i = 0; i < heartPoints.length; i++) {
                let dx = pointerPosition.x - heartPoints[i].x;
                let dy = pointerPosition.y - heartPoints[i].y;
                let distance = dx * dx + dy * dy;
                if (distance < minDistance) {
                    minDistance = distance;
                    newPaddleStart = i;
                }
            }
            paddleStartIndex = newPaddleStart;
        }

        // Update paddle based on keyboard input
        function updatePaddleKeyboard() {
            if (keyboardControl.left) {
                paddleStartIndex = (paddleStartIndex - 5 + heartPoints.length) % heartPoints.length;
            }
            if (keyboardControl.right) {
                paddleStartIndex = (paddleStartIndex + 5) % heartPoints.length;
            }
        }

        // Update ball position and handle collisions
        function updateBall() {
            if (gameEnding || gameOver) {
                // Continue moving the ball off-screen
                ball.x += ball.velocity.x;
                ball.y += ball.velocity.y;

                // Check if the ball is completely off the screen
                if (ball.x < -ball.radius || ball.x > canvas.width + ball.radius ||
                    ball.y < -ball.radius || ball.y > canvas.height + ball.radius) {
                    // End the game after the ball has flown off-screen
                    gameOver = true;
                    cancelAnimationFrame(animationFrameId);
                    document.getElementById('gameOver').style.display = 'block';
                    document.getElementById('restartButton').style.display = 'block';
                    // Remove 'playing' class to show cursor again
                    document.body.classList.remove('playing');
                }
                return; // Exit the function to prevent further collision checks
            }

            // Move the ball
            ball.x += ball.velocity.x;
            ball.y += ball.velocity.y;

            // Check if the ball is outside the heart boundary
            let isCurrentlyOutside = !ctx.isPointInPath(heartPath, ball.x, ball.y);

            if (isCurrentlyOutside && !isBallOutside) {
                // Ball has just moved outside - initiate game ending sequence
                gameEnding = true;
                return;
            }

            // Check collision with paddle
            if (isBallCollidingWithPaddle()) {
                // Find the collision point
                let collisionPoint = findCollisionPoint();

                if (collisionPoint) {
                    // Calculate normal vector at collision point
                    let normalVector = { x: ball.x - collisionPoint.x, y: ball.y - collisionPoint.y };

                    // Reflect the velocity vector
                    let reflectedVelocity = reflectVelocity(ball.velocity, normalVector);
                    ball.velocity = reflectedVelocity;

                    // Increase score
                    score++;
                    updateScoreboard();

                    // Increase ball speed slightly
                    ball.speed += 0.2; // Adjust the increment as needed
                    let speedRatio = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                    ball.velocity.x *= speedRatio;
                    ball.velocity.y *= speedRatio;

                    // Move ball slightly away from paddle to prevent sticking
                    ball.x += ball.velocity.x * 2;
                    ball.y += ball.velocity.y * 2;

                    // Set paddle hit flag for visual feedback
                    isPaddleHit = true;
                }
            }
        }

        // Find the collision point between the ball and the paddle
        function findCollisionPoint() {
            let endIndex = (paddleStartIndex + paddleLength) % heartPoints.length;

            // Gather paddle points
            let paddlePoints = [];
            if (paddleStartIndex < endIndex) {
                for (let i = paddleStartIndex; i <= endIndex; i++) {
                    paddlePoints.push(heartPoints[i]);
                }
            } else {
                for (let i = paddleStartIndex; i < heartPoints.length; i++) {
                    paddlePoints.push(heartPoints[i]);
                }
                for (let i = 0; i <= endIndex; i++) {
                    paddlePoints.push(heartPoints[i]);
                }
            }

            // Find the closest paddle point to the ball
            let minDistance = Infinity;
            let closestPoint = null;
            for (let point of paddlePoints) {
                let distance = Math.hypot(ball.x - point.x, ball.y - point.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                }
            }

            // If the closest point is within collision range, return it
            if (closestPoint && minDistance <= ball.radius + (ctx.lineWidth / 2)) {
                return closestPoint;
            }

            return null;
        }

        // Check if ball is colliding with paddle
        function isBallCollidingWithPaddle() {
            return findCollisionPoint() !== null;
        }

        // Draw ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'magenta';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'magenta';
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Update scoreboard
        function updateScoreboard() {
            document.getElementById('scoreboard').innerHTML = `
                <div>heart centered</div>
                <div>score: ${score}</div>
            `;
        }

        // End game and show Game Over screen
        function endGame() {
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('restartButton').style.display = 'block';
            // Remove 'playing' class to show cursor again
            document.body.classList.remove('playing');
        }

        // Main game loop
        function gameLoop() {
            if (gameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawHeart();
            drawPaddle();
            updateBall();
            drawBall();
            updateScoreboard();

            // Handle keyboard input
            updatePaddleKeyboard();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Start the game
        function startGame() {
            // Hide start button
            document.getElementById('startButton').style.display = 'none';
            // Add 'playing' class to hide cursor
            document.body.classList.add('playing');
            // Reset variables
            score = 0;
            gameStarted = true;
            gameOver = false;
            gameEnding = false;
            ball.speed = 3; // Slower starting speed
            setBallStartingPosition();
            initializeBallVelocity(); // Set random initial velocity
            updateScoreboard();
            // Start game loop
            gameLoop();
        }

        // Restart the game
        function restartGame() {
            // Hide game over and restart button
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            // Add 'playing' class to hide cursor
            document.body.classList.add('playing');
            // Reset variables
            score = 0;
            gameStarted = true;
            gameOver = false;
            gameEnding = false;
            ball.speed = 3; // Slower starting speed
            setBallStartingPosition();
            initializeBallVelocity(); // Set random initial velocity
            updateScoreboard();
            // Start game loop
            gameLoop();
        }

        // Initialize game on page load
        resizeCanvas();
        generateHeartPoints();
        setBallStartingPosition(); // Ensure ball starts inside the heart

        // Show start button
        document.getElementById('startButton').style.display = 'block';
    </script>
</body>
</html>

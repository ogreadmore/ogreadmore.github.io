<!DOCTYPE html>
<html>
<head>
    <title>heart centered</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
            height: 100vh;
            width: 100vw;
            /* Cursor visibility handled via 'playing' class */
        }

        /* Hide cursor only when the game is playing */
        body.playing {
            cursor: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #000;
            z-index: 5;
        }

        /* Scoreboard Styles */
        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 3vh; /* Increased font size for the title */
            user-select: none;
            z-index: 10;
            text-align: left;
        }

        #scoreboard .title {
            font-size: 4vh; /* Bigger font for "Heart Centered" */
            margin-bottom: 10px; /* Increased space between title and score */
        }

        #scoreboard .score {
            font-size: 2.5vh;
        }

        /* Game Over and Restart Button Styles */
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
        }

        #restartButton {
            position: absolute;
            top: 55%; /* Positioned 15% below the GAME OVER message */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 15px 30px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
            display: none;
        }

        #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Start Button Styles */
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
        }

        #startButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Paused Overlay Styles */
        #pausedOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: magenta;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 20;
            font-family: 'Press Start 2P', cursive;
            font-size: 4vh;
            user-select: none;
            cursor: pointer; /* Indicate that it can be interacted with */
        }

        /* Flex container for paused overlay */
        #pausedOverlayContent {
            display: flex;
            height: 100%;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        /* Media Query for Mobile Devices */
        @media only screen and (max-width: 768px) {
            #scoreboard .title {
                font-size: 3vh;
            }

            #scoreboard .score {
                font-size: 2vh;
            }

            #gameOver {
                font-size: 4vh;
            }

            #startButton, #restartButton {
                font-size: 1.5rem;
                padding: 10px 20px;
            }

            #pausedOverlay {
                font-size: 3vh;
            }
        }
    </style>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Scoreboard -->
    <div id="scoreboard">
        <div class="title">heart centered</div>
        <div class="score">score: 0</div>
    </div>
    <!-- Game Over and Restart Button -->
    <div id="gameOver">game over</div>
    <div id="restartButton">restart</div>
    <!-- Start Button -->
    <div id="startButton">start game</div>
    <!-- Paused Overlay -->
    <div id="pausedOverlay">
        <div id="pausedOverlayContent">
            <div>PAUSED</div>
            <div style="font-size: 2vh; margin-top: 2vh;">Move your mouse back to resume</div>
        </div>
    </div>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");

            // Canvas setup
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            const ctx = canvas.getContext('2d');
            console.log("Canvas and context initialized.");

            // Game variables
            let heartPath = new Path2D();
            let heartPoints = [];
            const desiredArcLength = 1; // Desired distance between points in pixels
            const paddlePixelLength = 400; // Desired physical paddle length in pixels
            let paddleLength = 0; // Number of points in the paddle, to be calculated
            let paddleStartIndex = 0.0; // Allow floating point for smooth movement
            let targetPaddleStartIndex = 0.0; // Target index for smooth paddle movement
            let score = 0;
            let gameStarted = false;
            let gameOver = false;
            let gameEnding = false; // Flag to manage game ending sequence
            let paused = false; // Flag to manage paused state
            let animationFrameId;

            // Ball properties
            let ball = {
                x: 0,
                y: 0,
                radius: 10, // Increased for better visibility
                speed: 2.5, // Reduced from 3 for slower starting speed
                velocity: { x: 0, y: 0 }, // Velocity vector
                prevX: 0, // Previous X position (for CCD)
                prevY: 0  // Previous Y position (for CCD)
            };

            // Maximum ball speed to prevent skipping collisions
            const MAX_BALL_SPEED = 10; // Adjust as needed

            // Pointer (mouse or touch) controls
            let pointerPosition = { x: canvas.width / 2, y: canvas.height / 2 };

            // Keyboard controls
            let keyboardControl = { left: false, right: false };

            // Paddle movement speeds
            const paddleSpeed = 150; // Used for moving towards target
            const keyboardMoveSpeed = 100; // Speed for keyboard controls (points per second)

            // Flag to track if the ball is currently outside the heart
            let isBallOutside = false;

            // Flag to track if the paddle was hit (for visual feedback)
            let isPaddleHit = false;

            // Paused Overlay Element
            const pausedOverlay = document.getElementById('pausedOverlay');

            // Detect if the device is mobile
            const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("Is mobile device:", isMobile);

            // Throttle function to limit the rate of function calls (optional, can help performance)
            function throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }

            // Event listeners for mouse
            canvas.addEventListener('mousemove', throttle(function (e) {
                pointerPosition.x = e.clientX;
                pointerPosition.y = e.clientY;
                if (gameStarted && !gameOver && !gameEnding && !paused && !isMobile) {
                    updateTargetPaddleIndex();
                }
            }, 16)); // Throttle to ~60fps

            // Event listeners for touch
            canvas.addEventListener('touchmove', throttle(function (e) {
                e.preventDefault();
                if (e.touches.length > 0) {
                    pointerPosition.x = e.touches[0].clientX;
                    pointerPosition.y = e.touches[0].clientY;
                    if (gameStarted && !gameOver && !gameEnding && !paused && isMobile) {
                        // For mobile, set target paddle index smoothly
                        setPaddleToPointer();
                    }
                }
            }, 16), { passive: false }); // Throttle to ~60fps

            // Event listeners for keyboard
            document.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    keyboardControl.left = true;
                    console.log("Left key pressed.");
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    keyboardControl.right = true;
                    console.log("Right key pressed.");
                }
            });

            document.addEventListener('keyup', function(e) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    keyboardControl.left = false;
                    console.log("Left key released.");
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    keyboardControl.right = false;
                    console.log("Right key released.");
                }
            });

            // Event listeners for mouse leaving and entering the canvas
            canvas.addEventListener('mouseleave', function (e) {
                if (gameStarted && !gameOver && !gameEnding) {
                    pauseGame();
                }
            });

            canvas.addEventListener('mouseenter', function (e) {
                if (gameStarted && paused) {
                    resumeGame();
                }
            });

            // Event listener for mouse entering the paused overlay to resume the game
            pausedOverlay.addEventListener('mouseenter', function (e) {
                if (gameStarted && paused) {
                    resumeGame();
                }
            });

            // Resize canvas to fit the window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
                generateHeartPoints(); // Regenerate heart points to fit new size
                if (!gameStarted) {
                    setBallStartingPosition();
                }
            }
            window.addEventListener('resize', resizeCanvas);

            // Generate heart shape points with uniform arc-length spacing
            function generateHeartPoints() {
                heartPoints = [];
                let t = 0;
                const deltaT = 0.001; // Initial t increment
                let lastPoint = calculateHeartPoint(t);
                heartPoints.push(lastPoint);
                t += deltaT;

                while (t < 2 * Math.PI) {
                    let currentPoint = calculateHeartPoint(t);
                    let distance = Math.hypot(currentPoint.x - lastPoint.x, currentPoint.y - lastPoint.y);
                    if (distance >= desiredArcLength) {
                        heartPoints.push(currentPoint);
                        lastPoint = currentPoint;
                    }
                    t += deltaT;
                }

                // Scale and center the heart
                const scale = Math.min(canvas.width, canvas.height) / 40;
                heartPoints = heartPoints.map(point => ({
                    x: point.x * scale + canvas.width / 2,
                    y: point.y * scale + canvas.height / 2
                }));

                console.log(`Generated ${heartPoints.length} heart points.`);

                // Create the heart path for collision detection
                heartPath = new Path2D();
                heartPath.moveTo(heartPoints[0].x, heartPoints[0].y);
                for (let i = 1; i < heartPoints.length; i++) {
                    heartPath.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
                heartPath.closePath();

                // Calculate paddleLength based on desired physical length
                // Approximate average distance between points
                let totalDistance = 0;
                for (let i = 1; i < heartPoints.length; i++) {
                    totalDistance += Math.hypot(heartPoints[i].x - heartPoints[i - 1].x, heartPoints[i].y - heartPoints[i - 1].y);
                }
                const averageDistance = totalDistance / (heartPoints.length - 1);
                paddleLength = Math.round(paddlePixelLength / averageDistance);
                console.log(`Paddle length set to ${paddleLength} points.`);
            }

            // Calculate a point on the heart for a given t
            function calculateHeartPoint(t) {
                // Heart shape parametric equations
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                return { x: x, y: -y }; // Invert y for canvas coordinates
            }

            // Set ball starting position inside the heart
            function setBallStartingPosition() {
                // Start at the center of the heart
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                console.log(`Ball starting position set to (${ball.x}, ${ball.y})`);

                // Initialize velocity if not set
                if (!gameStarted) {
                    initializeBallVelocity();
                }
            }

            // Initialize ball velocity with a random angle
            function initializeBallVelocity() {
                let angleDegrees = Math.random() * 120 + 30; // 30 to 150 degrees
                let angleRadians = angleDegrees * (Math.PI / 180);
                ball.velocity.x = ball.speed * Math.cos(angleRadians);
                ball.velocity.y = ball.speed * Math.sin(angleRadians);
                console.log(`Ball velocity initialized to (${ball.velocity.x.toFixed(2)}, ${ball.velocity.y.toFixed(2)})`);
            }

            // Reflect the ball's velocity vector based on the normal vector
            function reflectVelocity(incident, normal) {
                // Normalize the normal vector
                let normLength = Math.hypot(normal.x, normal.y);
                if (normLength === 0) {
                    console.warn("Normal vector has zero length. Velocity not reflected.");
                    return { x: incident.x, y: incident.y }; // Prevent division by zero
                }
                let normalUnit = { x: normal.x / normLength, y: normal.y / normLength };

                // Compute dot product
                let dot = incident.x * normalUnit.x + incident.y * normalUnit.y;

                // Compute reflected vector
                let reflected = {
                    x: incident.x - 2 * dot * normalUnit.x,
                    y: incident.y - 2 * dot * normalUnit.y
                };

                console.log(`Velocity reflected to (${reflected.x.toFixed(2)}, ${reflected.y.toFixed(2)})`);
                return reflected;
            }

            // Calculate the normal vector of a paddle segment
            function calculateNormal(segment) {
                // Calculate the direction vector of the segment
                let dx = segment.end.x - segment.start.x;
                let dy = segment.end.y - segment.start.y;
                
                // Calculate the normal vector (perpendicular to the direction)
                let normal = { x: -dy, y: dx };
                
                // Normalize the normal vector
                let length = Math.hypot(normal.x, normal.y);
                if (length === 0) return { x: 0, y: 0 };
                return { x: normal.x / length, y: normal.y / length };
            }

            // Draw heart outline with dotted line
            function drawHeart() {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line pattern
                ctx.stroke(heartPath);
                ctx.setLineDash([]); // Reset to solid for other drawings
                // Optional: Draw filled heart for visibility
                // ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                // ctx.fill(heartPath);
                console.log("Heart drawn.");
            }

            // Draw paddle with increased thickness and consistent length
            function drawPaddle() {
                ctx.beginPath();
                ctx.strokeStyle = 'magenta';
                ctx.lineWidth = 25; // Increased for better visibility
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'magenta';
                let startIndex = Math.floor(paddleStartIndex) % heartPoints.length;
                let endIndex = (startIndex + paddleLength) % heartPoints.length;

                // Handle wrap-around
                if (startIndex < endIndex) {
                    ctx.moveTo(heartPoints[startIndex].x, heartPoints[startIndex].y);
                    for (let i = startIndex + 1; i <= endIndex; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                } else {
                    ctx.moveTo(heartPoints[startIndex].x, heartPoints[startIndex].y);
                    for (let i = startIndex + 1; i < heartPoints.length; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                    for (let i = 0; i <= endIndex; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                }

                ctx.stroke();

                // Add a brief glow effect if paddle was hit
                if (isPaddleHit) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 30; // Slightly thicker for glow effect
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = 'yellow';
                    if (startIndex < endIndex) {
                        ctx.moveTo(heartPoints[startIndex].x, heartPoints[startIndex].y);
                        for (let i = startIndex + 1; i <= endIndex; i++) {
                            ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                        }
                    } else {
                        ctx.moveTo(heartPoints[startIndex].x, heartPoints[startIndex].y);
                        for (let i = startIndex + 1; i < heartPoints.length; i++) {
                            ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                        }
                        for (let i = 0; i <= endIndex; i++) {
                            ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                        }
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0; // Reset shadow
                    isPaddleHit = false; // Reset the flag
                }

                ctx.shadowBlur = 0; // Reset shadow for other drawings
                console.log(`Paddle drawn from index ${startIndex} to ${endIndex}`);
            }

            // Update target paddle index based on pointer position
            function updateTargetPaddleIndex() {
                let minDistance = Infinity;
                let newTargetPaddleStart = targetPaddleStartIndex;
                for (let i = 0; i < heartPoints.length; i++) {
                    let dx = pointerPosition.x - heartPoints[i].x;
                    let dy = pointerPosition.y - heartPoints[i].y;
                    let distance = dx * dx + dy * dy;
                    if (distance < minDistance) {
                        minDistance = distance;
                        newTargetPaddleStart = i;
                    }
                }
                targetPaddleStartIndex = newTargetPaddleStart;
                console.log(`Desktop: Target paddle index updated to ${targetPaddleStartIndex}`);
            }

            // Directly set paddle target based on touch angle (for mobile devices)
            function setPaddleToPointer() {
                // Calculate angle from heart center to touch position
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dx = pointerPosition.x - centerX;
                const dy = centerY - pointerPosition.y; // Inverted y-axis for angle calculation
                let angle = Math.atan2(dy, dx);
                if (angle < 0) angle += 2 * Math.PI; // Normalize angle to [0, 2π]
                console.log(`Touch angle: ${(angle * 180 / Math.PI).toFixed(2)} degrees`);

                // Find the closest heart point based on angle
                let closestIndex = 0;
                let minAngleDiff = Infinity;
                const totalPoints = heartPoints.length;
                for (let i = 0; i < totalPoints; i++) {
                    // Assuming heartPoints are ordered from 0 to 2π
                    let point = heartPoints[i];
                    let pointAngle = Math.atan2(centerY - point.y, point.x - centerX);
                    if (pointAngle < 0) pointAngle += 2 * Math.PI;
                    let angleDiff = Math.abs(angle - pointAngle);
                    angleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff); // Handle wrap-around
                    if (angleDiff < minAngleDiff) {
                        minAngleDiff = angleDiff;
                        closestIndex = i;
                    }
                }

                targetPaddleStartIndex = closestIndex;
                console.log(`Mobile: Target paddle index set to ${targetPaddleStartIndex} based on angle`);
            }

            // Update paddle based on keyboard input with time-based movement
            function updatePaddleKeyboard(deltaTime) {
                let movement = 0;
                if (keyboardControl.left) {
                    movement -= keyboardMoveSpeed * deltaTime;
                }
                if (keyboardControl.right) {
                    movement += keyboardMoveSpeed * deltaTime;
                }
                targetPaddleStartIndex += movement;
                targetPaddleStartIndex = (targetPaddleStartIndex + heartPoints.length) % heartPoints.length;
                console.log(`Keyboard movement: ${movement.toFixed(2)}, new target index: ${targetPaddleStartIndex}`);
            }

            // Update paddle towards target index for smooth touch/mouse control
            function updatePaddleTowardsTarget(deltaTime) {
                if (Math.abs(targetPaddleStartIndex - paddleStartIndex) < 0.1) return; // Threshold to prevent jitter

                let difference = targetPaddleStartIndex - paddleStartIndex;

                // Handle wrap-around difference
                if (difference > heartPoints.length / 2) {
                    difference -= heartPoints.length;
                } else if (difference < -heartPoints.length / 2) {
                    difference += heartPoints.length;
                }

                let direction = difference > 0 ? 1 : -1;

                let movement = paddleSpeed * deltaTime * 0.5; // Adjust multiplier for smoother movement

                if (Math.abs(difference) < movement) {
                    paddleStartIndex = targetPaddleStartIndex;
                } else {
                    paddleStartIndex += direction * movement;
                }

                // Wrap around if necessary
                paddleStartIndex = (paddleStartIndex + heartPoints.length) % heartPoints.length;
                console.log(`Paddle moved to index ${paddleStartIndex.toFixed(2)}`);
            }

            // Function to check if a circle (ball) intersects with a line segment
            function detectCircleLineSegmentIntersection(ball, prevBall, segment) {
                const x1 = segment.start.x;
                const y1 = segment.start.y;
                const x2 = segment.end.x;
                const y2 = segment.end.y;

                const dx = ball.x - prevBall.x;
                const dy = ball.y - prevBall.y;

                const fx = prevBall.x - x1;
                const fy = prevBall.y - y1;

                const segDx = x2 - x1;
                const segDy = y2 - y1;

                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - ball.radius * ball.radius;

                let discriminant = b * b - 4 * a * c;

                if (discriminant < 0) {
                    // No intersection
                    return null;
                }

                discriminant = Math.sqrt(discriminant);

                let t1 = (-b - discriminant) / (2 * a);
                let t2 = (-b + discriminant) / (2 * a);

                if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
                    let t = t1;
                    if (t1 < 0 || t1 > 1) t = t2;
                    if (t < 0 || t > 1) return null;

                    const collisionX = prevBall.x + dx * t;
                    const collisionY = prevBall.y + dy * t;

                    return { x: collisionX, y: collisionY };
                }

                return null;
            }

            // Function to retrieve all line segments of the paddle
            function getPaddleSegments() {
                let segments = [];
                let startIndex = Math.floor(paddleStartIndex) % heartPoints.length;
                let endIndex = (startIndex + paddleLength) % heartPoints.length;

                if (startIndex < endIndex) {
                    for (let i = startIndex; i < endIndex; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[i + 1]
                        });
                    }
                } else {
                    // Wrap-around case
                    for (let i = startIndex; i < heartPoints.length - 1; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[i + 1]
                        });
                    }
                    for (let i = 0; i < endIndex; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[i + 1]
                        });
                    }
                }

                return segments;
            }

            // Update ball position and handle collisions
            function updateBall() {
                if (gameEnding || gameOver || paused) {
                    // Continue moving the ball off-screen or do nothing if paused
                    if (!paused) {
                        ball.prevX = ball.x;
                        ball.prevY = ball.y;
                        ball.x += ball.velocity.x;
                        ball.y += ball.velocity.y;

                        // Check if the ball is completely off the screen
                        if (ball.x < -ball.radius || ball.x > canvas.width + ball.radius ||
                            ball.y < -ball.radius || ball.y > canvas.height + ball.radius) {
                            // End the game after the ball has flown off-screen
                            gameOver = true;
                            cancelAnimationFrame(animationFrameId);
                            document.getElementById('gameOver').style.display = 'block';
                            document.getElementById('restartButton').style.display = 'block';
                            // Remove 'playing' class to show cursor again
                            document.body.classList.remove('playing');
                            console.log("Game over: Ball flew off-screen.");
                        }
                    }
                    return; // Exit the function to prevent further collision checks
                }

                // Store previous position
                ball.prevX = ball.x;
                ball.prevY = ball.y;

                // Move the ball
                ball.x += ball.velocity.x;
                ball.y += ball.velocity.y;
                console.log(`Ball position: (${ball.x.toFixed(2)}, ${ball.y.toFixed(2)})`);

                // Check if the ball is outside the heart boundary
                let isCurrentlyOutside = !ctx.isPointInPath(heartPath, ball.x, ball.y);

                if (isCurrentlyOutside && !isBallOutside) {
                    // Ball has just moved outside - initiate game ending sequence
                    gameEnding = true;
                    console.log("Ball moved outside the heart boundary.");
                    return;
                }

                // Update isBallOutside flag
                isBallOutside = isCurrentlyOutside;

                // Continuous Collision Detection (CCD)
                let collisionDetected = false;
                let collisionPoint = null;
                let collidedSegment = null;
                let paddleSegments = getPaddleSegments();

                for (let segment of paddleSegments) {
                    let intersection = detectCircleLineSegmentIntersection(ball, { x: ball.prevX, y: ball.prevY }, segment);
                    if (intersection) {
                        collisionDetected = true;
                        collisionPoint = intersection;
                        collidedSegment = segment;
                        console.log(`Collision detected at (${collisionPoint.x.toFixed(2)}, ${collisionPoint.y.toFixed(2)})`);
                        break; // Exit loop after first collision
                    }
                }

                if (collisionDetected && collisionPoint && collidedSegment) {
                    // Calculate the normal based on the paddle segment
                    let normalVector = calculateNormal(collidedSegment);
                    console.log(`Normal Vector: (${normalVector.x.toFixed(2)}, ${normalVector.y.toFixed(2)})`);

                    // Reflect the velocity vector based on the normal vector
                    ball.velocity = reflectVelocity(ball.velocity, normalVector);

                    // Adjust the ball's position to be just outside the paddle
                    ball.x = collisionPoint.x + normalVector.x * (ball.radius + 1);
                    ball.y = collisionPoint.y + normalVector.y * (ball.radius + 1);
                    console.log(`Ball position adjusted to (${ball.x.toFixed(2)}, ${ball.y.toFixed(2)})`);

                    // Increase score
                    score++;
                    updateScoreboard();

                    // Increase ball speed slightly, ensuring it doesn't exceed MAX_BALL_SPEED
                    ball.speed = Math.min(ball.speed + 0.2, MAX_BALL_SPEED);
                    let speedRatio = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                    ball.velocity.x *= speedRatio;
                    ball.velocity.y *= speedRatio;
                    console.log(`Ball speed updated to ${ball.speed}`);

                    // Set paddle hit flag for visual feedback
                    isPaddleHit = true;
                    console.log(`Paddle hit via CCD! New velocity: (${ball.velocity.x.toFixed(2)}, ${ball.velocity.y.toFixed(2)})`);
                }

                // If collision wasn't detected via CCD, check for discrete collision as a fallback
                if (!collisionDetected && isBallCollidingWithPaddle()) {
                    let fallbackCollisionPoint = findCollisionPoint();
                    if (fallbackCollisionPoint) {
                        let normalVector = { x: ball.x - fallbackCollisionPoint.x, y: ball.y - fallbackCollisionPoint.y };
                        ball.velocity = reflectVelocity(ball.velocity, normalVector);

                        // Move the ball slightly away from paddle
                        ball.x += ball.velocity.x * 2;
                        ball.y += ball.velocity.y * 2;
                        console.log(`Ball position after fallback adjustment to (${ball.x.toFixed(2)}, ${ball.y.toFixed(2)})`);

                        // Increase score
                        score++;
                        updateScoreboard();

                        // Increase ball speed slightly, ensuring it doesn't exceed MAX_BALL_SPEED
                        ball.speed = Math.min(ball.speed + 0.2, MAX_BALL_SPEED);
                        let speedRatioFallback = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                        ball.velocity.x *= speedRatioFallback;
                        ball.velocity.y *= speedRatioFallback;
                        console.log(`Ball speed updated to ${ball.speed}`);

                        // Set paddle hit flag for visual feedback
                        isPaddleHit = true;
                        console.log(`Paddle hit via fallback! New velocity: (${ball.velocity.x.toFixed(2)}, ${ball.velocity.y.toFixed(2)})`);
                    }
                }
            }

            // Find the collision point between the ball and the paddle (discrete collision detection)
            function findCollisionPoint() {
                let startIndex = Math.floor(paddleStartIndex) % heartPoints.length;
                let endIndex = (startIndex + paddleLength) % heartPoints.length;

                // Gather paddle points
                let paddlePoints = [];
                if (startIndex < endIndex) {
                    for (let i = startIndex; i <= endIndex; i++) {
                        paddlePoints.push(heartPoints[i]);
                    }
                } else {
                    for (let i = startIndex; i < heartPoints.length; i++) {
                        paddlePoints.push(heartPoints[i]);
                    }
                    for (let i = 0; i <= endIndex; i++) {
                        paddlePoints.push(heartPoints[i]);
                    }
                }

                // Find the closest paddle point to the ball
                let minDistance = Infinity;
                let closestPoint = null;
                for (let point of paddlePoints) {
                    let distance = Math.hypot(ball.x - point.x, ball.y - point.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = point;
                    }
                }

                // If the closest point is within collision range, return it
                if (closestPoint && minDistance <= ball.radius + (ctx.lineWidth / 2)) {
                    return closestPoint;
                }

                return null;
            }

            // Check if ball is colliding with paddle
            function isBallCollidingWithPaddle() {
                return findCollisionPoint() !== null;
            }

            // Draw ball
            function drawBall() {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'magenta';
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'magenta';
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
                console.log(`Ball drawn at (${ball.x.toFixed(2)}, ${ball.y.toFixed(2)})`);
            }

            // Update scoreboard
            function updateScoreboard() {
                document.querySelector('#scoreboard .score').innerText = `Score: ${score}`;
                console.log(`Score updated to ${score}`);
            }

            // Pause the game
            function pauseGame() {
                paused = true;
                cancelAnimationFrame(animationFrameId);
                pausedOverlay.style.display = 'flex';
                console.log('Game paused.');
            }

            // Resume the game
            function resumeGame() {
                paused = false;
                pausedOverlay.style.display = 'none';
                lastFrameTime = performance.now(); // Reset the lastFrameTime to avoid large deltaTime
                console.log('Game resumed.');
                gameLoop(); // Restart the game loop
            }

            // End game and show Game Over screen
            function endGame() {
                gameOver = true;
                cancelAnimationFrame(animationFrameId);
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('restartButton').style.display = 'block';
                // Remove 'playing' class to show cursor again
                document.body.classList.remove('playing');
                console.log("Game over.");
            }

            // Main game loop with deltaTime for smooth movement
            let lastFrameTime = performance.now();
            function gameLoop(currentTime = performance.now()) {
                if (gameOver || paused) return;

                // Calculate deltaTime in seconds
                let deltaTime = (currentTime - lastFrameTime) / 1000;
                lastFrameTime = currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawHeart();
                drawPaddle();
                updateBall();
                drawBall();
                updateScoreboard();

                // Handle keyboard input with deltaTime
                updatePaddleKeyboard(deltaTime);

                // Handle touch/mouse control towards target paddle index
                updatePaddleTowardsTarget(deltaTime);

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // Select buttons
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');

            // Add event listeners
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Define startGame and restartGame normally
            function startGame() {
                console.log("Start Game button clicked.");
                // Hide start button
                startButton.style.display = 'none';
                // Add 'playing' class to hide cursor
                document.body.classList.add('playing');
                // Reset variables
                score = 0;
                gameStarted = true;
                gameOver = false;
                gameEnding = false;
                paused = false;
                ball.speed = 2.5; // Slower starting speed
                setBallStartingPosition();
                initializeBallVelocity(); // Set random initial velocity
                updateScoreboard();
                // Reset lastFrameTime for consistent deltaTime
                lastFrameTime = performance.now();
                // Hide paused overlay if visible
                pausedOverlay.style.display = 'none';
                // Initialize target paddle index
                targetPaddleStartIndex = paddleStartIndex;
                // Start game loop
                gameLoop();
                console.log('Game started.');
            }

            function restartGame() {
                console.log("Restart Game button clicked.");
                // Hide game over and restart button
                document.getElementById('gameOver').style.display = 'none';
                restartButton.style.display = 'none';
                // Add 'playing' class to hide cursor
                document.body.classList.add('playing');
                // Reset variables
                score = 0;
                gameStarted = true;
                gameOver = false;
                gameEnding = false;
                paused = false;
                ball.speed = 2.5; // Slower starting speed
                setBallStartingPosition();
                initializeBallVelocity(); // Set random initial velocity
                updateScoreboard();
                // Reset lastFrameTime for consistent deltaTime
                lastFrameTime = performance.now();
                // Hide paused overlay if visible
                pausedOverlay.style.display = 'none';
                // Initialize target paddle index
                targetPaddleStartIndex = paddleStartIndex;
                // Start game loop
                gameLoop();
                console.log('Game restarted.');
            }

            // Initialize game on page load
            resizeCanvas();
            generateHeartPoints();
            setBallStartingPosition(); // Ensure ball starts inside the heart

            // Show start button
            startButton.style.display = 'block';
            console.log("Start Game button displayed.");
        });
    </script>
</body>
</html>

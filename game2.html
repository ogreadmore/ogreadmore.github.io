<!DOCTYPE html>
<html>
  <!-- Open Graph meta tags -->
  <meta property="og:title" content="heart centered">
  <meta property="og:description" content="the other most wholesame game I could think of">
  <meta property="og:image" content="/spreadlove-og.png">
  <meta property="og:url" content="https://tayloroliphant.com/game2.html"> 
  <meta property="og:type" content="website">
  <!-- End Open Graph meta tags -->
<head>
    <title>heart centered</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            position: relative;
            height: 100vh;
            width: 100vw;
            /* Cursor visibility handled via 'playing' class */
            transition: background-color 0.5s;
        }

        /* Night Mode */
        body.nightmode {
            background-color: #000000;
        }

        /* Hide cursor only when the game is playing */
        body.playing {
            cursor: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            z-index: 5;
        }

        /* Scoreboard Styles */
        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 3vh; /* Increased font size for the title */
            user-select: none;
            z-index: 10;
            text-align: left;
            pointer-events: none; /* Prevents interference with gameplay */
        }

        #scoreboard .title {
            font-size: 4vh; /* Bigger font for "Heart Centered" */
            margin-bottom: 10px; /* Increased space between title and score */
            word-wrap: break-word; /* Ensure text wraps if too long */
            max-width: 90vw; /* Prevent overflow by limiting width */
        }

        #scoreboard .score {
            font-size: 2.5vh;
        }

        /* Game Over and Restart Button Styles */
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 40px; /* Adds more space between game over and restart */
        }

        #restartButton {
            position: absolute;
            top: 50%; /* Positioned below the GAME OVER message */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 15px 30px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
            display: none;
        }

        #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Start Button Styles */
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
            display: none;
        }

        #startButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Paused Overlay Styles */
        #pausedOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: magenta;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 20;
            font-family: 'Press Start 2P', cursive;
            font-size: 4vh;
            user-select: none;
            cursor: pointer; /* Indicate that it can be interacted with */
        }

        /* Flex container for paused overlay */
        #pausedOverlayContent {
            display: flex;
            height: 100%;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        /* Menu Icon */
        #menuIcon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 25px;
            cursor: pointer;
            z-index: 15;
        }

        /* Hamburger Icon Lines */
        #menuIcon div {
            width: 100%;
            height: 4px;
            background-color: magenta;
            margin: 5px 0;
        }

        /* Menu Overlay */
        #menuOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            display: none;
            z-index: 25;
            overflow: auto;
            cursor: default; /* Ensure cursor is visible in menu */
        }

        body.nightmode #menuOverlay {
            background-color: black;
        }

        /* Close Button */
        #menuCloseButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 25px;
            cursor: pointer;
        }

        /* X Icon Lines */
        #menuCloseButton:before,
        #menuCloseButton:after {
            content: '';
            position: absolute;
            width: 100%;
            height: 4px;
            background-color: magenta;
            top: 10px;
            left: 0;
        }

        #menuCloseButton:before {
            transform: rotate(45deg);
        }

        #menuCloseButton:after {
            transform: rotate(-45deg);
        }

        /* Menu Content */
        #menuContent {
            margin-top: 80px;
            text-align: center;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
        }

        #menuContent h1 {
            font-size: 3rem;
            margin-bottom: 40px;
        }

        .menu-option {
            margin: 20px auto;
            max-width: 400px;
        }

        .menu-option label {
            display: block;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .menu-option input[type="range"] {
            width: 100%;
        }

        .menu-option input[type="checkbox"] {
            transform: scale(1.5);
            margin-top: 10px;
        }

        /* Media Query for Mobile Devices */
        @media only screen and (max-width: 768px) {
            #scoreboard .title {
                font-size: 3vh;
                max-width: 90vw;
            }

            #scoreboard .score {
                font-size: 2vh;
            }

            #gameOver {
                font-size: 4vh;
            }

            #startButton,
            #restartButton {
                font-size: 1.5rem;
                padding: 10px 20px;
            }

            #pausedOverlay {
                font-size: 3vh;
            }

            #menuIcon,
            #menuCloseButton {
                top: 10px;
                right: 10px;
                width: 25px;
                height: 20px;
            }

            #menuIcon div,
            #menuCloseButton:before,
            #menuCloseButton:after {
                height: 3px;
            }

            #menuContent h1 {
                font-size: 2rem;
            }

            .menu-option label {
                font-size: 1rem;
            }

            .menu-option input[type="range"] {
                width: 100%;
            }
        }
    </style>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Menu Icon -->
    <div id="menuIcon" onclick="openMenu()">
        <div></div>
        <div></div>
        <div></div>
    </div>

    <!-- Menu Overlay -->
    <div id="menuOverlay">
        <div id="menuCloseButton" onclick="closeMenu()"></div>
        <div id="menuContent">
            <h1>options</h1>
            <!-- Menu Options -->
            <div class="menu-option">
                <label for="puckSpeed">puck speed</label>
                <input type="range" id="puckSpeed" min="1" max="10" value="2.5" step="0.1">
            </div>
            <div class="menu-option">
                <label for="paddleSpeed">paddle speed</label>
                <input type="range" id="paddleSpeed" min="50" max="300" value="150" step="10">
            </div>
            <div class="menu-option">
                <label for="twoPaddleMode">2 paddle mode</label>
                <input type="checkbox" id="twoPaddleMode" checked>
            </div>
            <div class="menu-option">
                <label for="aiSkillLevel">ai skill level</label>
                <input type="range" id="aiSkillLevel" min="1" max="10" value="5" step="1">
            </div>
            <div class="menu-option">
                <label for="tracersToggle">tracers</label>
                <input type="checkbox" id="tracersToggle">
            </div>
            <div class="menu-option">
                <label for="nightModeToggle">night mode</label>
                <input type="checkbox" id="nightModeToggle" checked>
            </div>
            <div class="menu-option">
                <label for="soundToggle">sound</label>
                <input type="checkbox" id="soundToggle" checked>
            </div>
            <div class="menu-option">
                <label for="volumeSlider">volume</label>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
            </div>
        </div>
    </div>

    <!-- Scoreboard -->
    <div id="scoreboard">
        <div class="title">heart centered</div>
        <div class="score">score: 0</div>
    </div>
    <!-- Game Over and Restart Button -->
    <div id="gameOver">game over</div>
    <div id="restartButton">restart</div>
    <!-- Start Button -->
    <div id="startButton">start game</div>
    <!-- Paused Overlay -->
    <div id="pausedOverlay">
        <div id="pausedOverlayContent">
            <div>PAUSED</div>
            <div style="font-size: 2vh; margin-top: 2vh;">Move your mouse back to resume</div>
        </div>
    </div>

    <!-- Audio Element -->
    <!-- Note: Ensure that 'bonk.mp3' is located in the same directory or adjust the path accordingly -->
    <!-- We'll preload multiple instances of the sound to prevent lag -->
    <!-- Preload multiple sounds for instant playback -->
    <audio id="hitSound1" src="bonk.mp3" preload="auto"></audio>
    <audio id="hitSound2" src="bonk.mp3" preload="auto"></audio>
    <audio id="hitSound3" src="bonk.mp3" preload="auto"></audio>
    <audio id="hitSound4" src="bonk.mp3" preload="auto"></audio>
    <audio id="hitSound5" src="bonk.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");

            // Canvas setup
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            const ctx = canvas.getContext('2d');
            console.log("Canvas and context initialized.");

            // Game variables
            let heartPath = new Path2D();
            let heartPoints = [];
            const desiredArcLength = 1; // Desired distance between points in pixels
            const paddlePixelLength = 400; // Desired physical paddle length in pixels
            let paddleLength = 0; // Number of points in the paddle, to be calculated
            let paddleStartIndex = 0.0; // Player's paddle
            let computerPaddleStartIndex = 0.0; // Computer's paddle
            let targetPaddleStartIndex = 0.0; // Target index for player's paddle movement
            let score = 0;
            let gameStarted = false;
            let gameOver = false;
            let gameEnding = false; // Flag to manage game ending sequence
            let paused = false; // Flag to manage paused state
            let animationFrameId;

            // Ball properties
            let ball = {
                x: 0,
                y: 0,
                radius: 10, // Increased for better visibility
                speed: 2.5, // Reduced from 3 for slower starting speed
                velocity: { x: 0, y: 0 }, // Velocity vector
                prevX: 0, // Previous X position (for CCD)
                prevY: 0  // Previous Y position (for CCD)
            };

            // Maximum ball speed to prevent skipping collisions
            const MAX_BALL_SPEED = 10; // Adjust as needed

            // Pointer (mouse or touch) controls
            let pointerPosition = { x: canvas.width / 2, y: canvas.height / 2 };

            // Keyboard controls
            let keyboardControl = { left: false, right: false };

            // Paddle movement speeds
            let paddleSpeed = 150; // Used for moving towards target
            let keyboardMoveSpeed = paddleSpeed; // Speed for keyboard controls (points per second)

            // Flag to track if the ball is currently outside the heart
            let isBallOutside = false;

            // Flag to track if the paddle was hit (for visual feedback)
            let isPaddleHit = false;

            // Paused Overlay Element
            const pausedOverlay = document.getElementById('pausedOverlay');

            // Detect if the device is mobile
            const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("Is mobile device:", isMobile);

            // Sound Elements
            const hitSounds = [
                document.getElementById('hitSound1'),
                document.getElementById('hitSound2'),
                document.getElementById('hitSound3'),
                document.getElementById('hitSound4'),
                document.getElementById('hitSound5')
            ];
            let hitSoundIndex = 0;

            // Menu Elements
            let menuOpen = false;
            const menuIcon = document.getElementById('menuIcon');
            const menuOverlay = document.getElementById('menuOverlay');
            const menuCloseButton = document.getElementById('menuCloseButton');
            const puckSpeedSlider = document.getElementById('puckSpeed');
            const nightModeToggle = document.getElementById('nightModeToggle');
            const soundToggle = document.getElementById('soundToggle');
            const volumeSlider = document.getElementById('volumeSlider');
            const twoPaddleModeToggle = document.getElementById('twoPaddleMode');
            const aiSkillLevelSlider = document.getElementById('aiSkillLevel');
            const paddleSpeedSlider = document.getElementById('paddleSpeed');
            const tracersToggle = document.getElementById('tracersToggle');

            // Heart outline color
            let heartOutlineColor = '#fff'; // Default to white

            // Pre-game countdown variables
            let preGameCountdown = 0;
            let preGamePulsing = false;
            let preGamePulseStartTime = 0;

            // 2 Paddle Mode variables
            let twoPaddleMode = true; // Start in two paddle mode by default
            let isPlayerTurn = false; // Keep track of whose turn it is
            let paddleThickness = 25; // Standard paddle thickness
            let activePaddleThickness = 35; // Thicker paddle when it's active

            // AI Skill Level
            let aiSkillLevel = 5; // Default to middle

            // Game Result
            let gameResult = ""; // "win" or "lose" or ""

            // Best of 3 scoring
            let playerScore = 0;
            let aiScore = 0;
            let gamesToWin = 3;

            // Tracers
            let enableTracers = false;
            const tracerCanvas = document.createElement('canvas');
            tracerCanvas.width = canvas.width;
            tracerCanvas.height = canvas.height;
            const tracerCtx = tracerCanvas.getContext('2d');

            // Throttle function to limit the rate of function calls (optional, can help performance)
            function throttle(func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }

            // Event listeners for mouse
            canvas.addEventListener('mousemove', throttle(function (e) {
                pointerPosition.x = e.clientX;
                pointerPosition.y = e.clientY;
                if (gameStarted && !gameOver && !gameEnding && !paused && !menuOpen && !isMobile) {
                    updateTargetPaddleIndex();
                }
            }, 16)); // Throttle to ~60fps

            // Event listeners for touch
            canvas.addEventListener('touchmove', throttle(function (e) {
                e.preventDefault();
                if (e.touches.length > 0) {
                    pointerPosition.x = e.touches[0].clientX;
                    pointerPosition.y = e.touches[0].clientY;
                    if (gameStarted && !gameOver && !gameEnding && !paused && isMobile) {
                        // For mobile, set target paddle index smoothly
                        setPaddleToPointer();
                    }
                }
            }, 16), { passive: false }); // Throttle to ~60fps

            // Event listeners for keyboard
            document.addEventListener('keydown', function (e) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    keyboardControl.left = true;
                    console.log("Left key pressed.");
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    keyboardControl.right = true;
                    console.log("Right key pressed.");
                }
            });

            document.addEventListener('keyup', function (e) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    keyboardControl.left = false;
                    console.log("Left key released.");
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    keyboardControl.right = false;
                    console.log("Right key released.");
                }
            });

            // Event listeners for mouse leaving and entering the canvas
            canvas.addEventListener('mouseleave', function (e) {
                if (gameStarted && !gameOver && !gameEnding && !menuOpen) {
                    pauseGame();
                }
            });

            canvas.addEventListener('mouseenter', function (e) {
                if (gameStarted && paused && !menuOpen) {
                    resumeGame();
                }
            });

            // Event listener for mouse entering the paused overlay to resume the game
            pausedOverlay.addEventListener('mouseenter', function (e) {
                if (gameStarted && paused && !menuOpen) {
                    resumeGame();
                }
            });

            // Resize canvas to fit the window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                tracerCanvas.width = canvas.width;
                tracerCanvas.height = canvas.height;
                console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
                generateHeartPoints(); // Regenerate heart points to fit new size
                if (!gameStarted) {
                    setBallStartingPosition();
                }
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Generate heart shape points with uniform arc-length spacing
            function generateHeartPoints() {
                heartPoints = [];
                let t = 0;
                const deltaT = 0.001; // Initial t increment
                let lastPoint = calculateHeartPoint(t);
                heartPoints.push(lastPoint);
                t += deltaT;

                while (t < 2 * Math.PI) {
                    let currentPoint = calculateHeartPoint(t);
                    let distance = Math.hypot(currentPoint.x - lastPoint.x, currentPoint.y - lastPoint.y);
                    if (distance >= desiredArcLength) {
                        heartPoints.push(currentPoint);
                        lastPoint = currentPoint;
                    }
                    t += deltaT;
                }

                // Scale and center the heart
                const scale = Math.min(canvas.width, canvas.height) / 40;
                heartPoints = heartPoints.map(point => ({
                    x: point.x * scale + canvas.width / 2,
                    y: point.y * scale + canvas.height / 2
                }));

                console.log(`Generated ${heartPoints.length} heart points.`);

                // Create the heart path for collision detection
                heartPath = new Path2D();
                heartPath.moveTo(heartPoints[0].x, heartPoints[0].y);
                for (let i = 1; i < heartPoints.length; i++) {
                    heartPath.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
                heartPath.closePath();

                // Calculate paddleLength based on desired physical length
                // Approximate average distance between points
                let totalDistance = 0;
                for (let i = 1; i < heartPoints.length; i++) {
                    totalDistance += Math.hypot(heartPoints[i].x - heartPoints[i - 1].x, heartPoints[i].y - heartPoints[i - 1].y);
                }
                const averageDistance = totalDistance / (heartPoints.length - 1);
                paddleLength = Math.round(paddlePixelLength / averageDistance);
                console.log(`Paddle length set to ${paddleLength} points.`);
            }
            generateHeartPoints();

            // Calculate a point on the heart for a given t
            function calculateHeartPoint(t) {
                // Heart shape parametric equations
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                return { x: x, y: -y }; // Invert y for canvas coordinates
            }

            // Set ball starting position inside the heart
            function setBallStartingPosition() {
                // Start at the center of the heart
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                console.log(`Ball starting position set to (${ball.x}, ${ball.y})`);

                // Initialize velocity if not set
                if (!gameStarted) {
                    initializeBallVelocity();
                }
            }
            setBallStartingPosition();

            // Initialize ball velocity with a random angle
            function initializeBallVelocity() {
                let angleDegrees;
                if (twoPaddleMode) {
                    // Start with computer hitting the puck towards the player
                    angleDegrees = Math.random() * 60 + 60; // 60 to 120 degrees
                } else {
                    angleDegrees = Math.random() * 360; // 0 to 360 degrees
                }
                let angleRadians = angleDegrees * (Math.PI / 180);
                ball.velocity.x = ball.speed * Math.cos(angleRadians);
                ball.velocity.y = ball.speed * Math.sin(angleRadians);
                console.log(`Ball velocity initialized to (${ball.velocity.x.toFixed(2)}, ${ball.velocity.y.toFixed(2)})`);
            }

            // Reflect the ball's velocity vector based on the normal vector
            function reflectVelocity(incident, normal) {
                // Normalize the normal vector
                let normLength = Math.hypot(normal.x, normal.y);
                if (normLength === 0) {
                    console.warn("Normal vector has zero length. Velocity not reflected.");
                    return { x: incident.x, y: incident.y }; // Prevent division by zero
                }
                let normalUnit = { x: normal.x / normLength, y: normal.y / normLength };

                // Compute dot product
                let dot = incident.x * normalUnit.x + incident.y * normalUnit.y;

                // Compute reflected vector
                let reflected = {
                    x: incident.x - 2 * dot * normalUnit.x,
                    y: incident.y - 2 * dot * normalUnit.y
                };

                console.log(`Velocity reflected to (${reflected.x.toFixed(2)}, ${reflected.y.toFixed(2)})`);
                return reflected;
            }

            // Calculate the normal vector of a paddle segment
            function calculateNormal(segment) {
                // Calculate the direction vector of the segment
                let dx = segment.end.x - segment.start.x;
                let dy = segment.end.y - segment.start.y;

                // Calculate the normal vector (perpendicular to the direction)
                let normal = { x: -dy, y: dx };

                // Normalize the normal vector
                let length = Math.hypot(normal.x, normal.y);
                if (length === 0) return { x: 0, y: 0 };
                return { x: normal.x / length, y: normal.y / length };
            }

            // Draw heart outline with dotted line
            function drawHeart() {
                ctx.strokeStyle = heartOutlineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dotted line pattern
                ctx.stroke(heartPath);
                ctx.setLineDash([]); // Reset to solid for other drawings
            }

            // Draw paddle with increased thickness and consistent length
            function drawPaddle() {
                // Draw computer's paddle first so player's paddle is always on top
                drawComputerPaddle();
                drawPlayerPaddle();

                // Add a brief glow effect if paddle was hit
                if (isPaddleHit) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 30; // Slightly thicker for glow effect
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = 'yellow';
                    if (twoPaddleMode) {
                        drawPaddleSegment(isPlayerTurn ? paddleStartIndex : computerPaddleStartIndex);
                    } else {
                        drawPaddleSegment(paddleStartIndex);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0; // Reset shadow
                    isPaddleHit = false; // Reset the flag
                }
            }

            function drawPlayerPaddle() {
                ctx.beginPath();
                ctx.strokeStyle = 'magenta';
                ctx.lineWidth = (isPlayerTurn || !twoPaddleMode) ? activePaddleThickness : paddleThickness;
                ctx.lineJoin = 'round';
                ctx.shadowBlur = (isPlayerTurn || !twoPaddleMode) ? 20 : 10;
                ctx.shadowColor = 'magenta';
                ctx.globalAlpha = (isPlayerTurn || !twoPaddleMode) ? 1 : 0.5; // Make inactive paddle semi-transparent
                drawPaddleSegment(paddleStartIndex);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }

            function drawComputerPaddle() {
                if (twoPaddleMode) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = !isPlayerTurn ? activePaddleThickness : paddleThickness;
                    ctx.lineJoin = 'round';
                    ctx.shadowBlur = !isPlayerTurn ? 20 : 10;
                    ctx.shadowColor = 'cyan';
                    ctx.globalAlpha = !isPlayerTurn ? 1 : 0.5; // Make inactive paddle semi-transparent
                    drawPaddleSegment(computerPaddleStartIndex);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }

            function drawPaddleSegment(startIndex) {
                let sIndex = Math.floor(startIndex) % heartPoints.length;
                let eIndex = (sIndex + paddleLength) % heartPoints.length;

                if (sIndex <= eIndex) {
                    ctx.moveTo(heartPoints[sIndex].x, heartPoints[sIndex].y);
                    for (let i = sIndex + 1; i <= eIndex; i++) {
                        ctx.lineTo(heartPoints[i % heartPoints.length].x, heartPoints[i % heartPoints.length].y);
                    }
                } else {
                    ctx.moveTo(heartPoints[sIndex].x, heartPoints[sIndex].y);
                    for (let i = sIndex + 1; i < heartPoints.length; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                    for (let i = 0; i <= eIndex; i++) {
                        ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                    }
                }
            }

            // Update target paddle index based on pointer position
            function updateTargetPaddleIndex() {
                let minDistance = Infinity;
                let newTargetPaddleStart = targetPaddleStartIndex;
                for (let i = 0; i < heartPoints.length; i++) {
                    let dx = pointerPosition.x - heartPoints[i].x;
                    let dy = pointerPosition.y - heartPoints[i].y;
                    let distance = dx * dx + dy * dy;
                    if (distance < minDistance) {
                        minDistance = distance;
                        newTargetPaddleStart = i;
                    }
                }
                targetPaddleStartIndex = newTargetPaddleStart;
            }

            // Directly set paddle target based on touch angle (for mobile devices)
            function setPaddleToPointer() {
                // Calculate angle from heart center to touch position
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dx = pointerPosition.x - centerX;
                const dy = centerY - pointerPosition.y; // Inverted y-axis for angle calculation
                let angle = Math.atan2(dy, dx);
                if (angle < 0) angle += 2 * Math.PI; // Normalize angle to [0, 2π]

                // Find the closest heart point based on angle
                let closestIndex = 0;
                let minAngleDiff = Infinity;
                const totalPoints = heartPoints.length;
                for (let i = 0; i < totalPoints; i++) {
                    // Assuming heartPoints are ordered from 0 to 2π
                    let point = heartPoints[i];
                    let pointAngle = Math.atan2(centerY - point.y, point.x - centerX);
                    if (pointAngle < 0) pointAngle += 2 * Math.PI;
                    let angleDiff = Math.abs(angle - pointAngle);
                    angleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff); // Handle wrap-around
                    if (angleDiff < minAngleDiff) {
                        minAngleDiff = angleDiff;
                        closestIndex = i;
                    }
                }

                targetPaddleStartIndex = closestIndex;
            }

            // Update paddle based on keyboard input with time-based movement
            function updatePaddleKeyboard(deltaTime) {
                let movement = 0;
                if (keyboardControl.left) {
                    movement -= keyboardMoveSpeed * deltaTime;
                }
                if (keyboardControl.right) {
                    movement += keyboardMoveSpeed * deltaTime;
                }
                targetPaddleStartIndex += movement;
                targetPaddleStartIndex = (targetPaddleStartIndex + heartPoints.length) % heartPoints.length;
            }

            // Update paddle towards target index for smooth touch/mouse control
            function updatePaddleTowardsTarget(deltaTime) {
                if (Math.abs(targetPaddleStartIndex - paddleStartIndex) < 0.1) return; // Threshold to prevent jitter

                let difference = targetPaddleStartIndex - paddleStartIndex;

                // Handle wrap-around difference
                if (difference > heartPoints.length / 2) {
                    difference -= heartPoints.length;
                } else if (difference < -heartPoints.length / 2) {
                    difference += heartPoints.length;
                }

                let direction = difference > 0 ? 1 : -1;

                let movement = paddleSpeed * deltaTime * 0.5; // Adjust multiplier for smoother movement

                if (Math.abs(difference) < movement) {
                    paddleStartIndex = targetPaddleStartIndex;
                } else {
                    paddleStartIndex += direction * movement;
                }

                // Wrap around if necessary
                paddleStartIndex = (paddleStartIndex + heartPoints.length) % heartPoints.length;
            }

            // Update computer paddle
            function updateComputerPaddle(deltaTime) {
                // Adjust computer paddle speed based on AI skill level
                let aiSpeed;
                if (aiSkillLevel <= 5) {
                    // Beginner to intermediate levels
                    aiSpeed = (aiSkillLevel / 5) * 100; // Scale between 20 and 100
                } else {
                    // Advanced levels
                    aiSpeed = 100 + ((aiSkillLevel - 5) / 5) * 150; // Scale between 100 and 250
                }

                let movement = aiSpeed * deltaTime;

                // Simple AI: move towards the predicted position of the ball
                let targetIndex = findClosestPointIndex(ball.x, ball.y);

                let difference = targetIndex - computerPaddleStartIndex;

                // Handle wrap-around difference
                if (difference > heartPoints.length / 2) {
                    difference -= heartPoints.length;
                } else if (difference < -heartPoints.length / 2) {
                    difference += heartPoints.length;
                }

                let direction = difference > 0 ? 1 : -1;

                if (Math.abs(difference) < movement) {
                    computerPaddleStartIndex = targetIndex;
                } else {
                    computerPaddleStartIndex += direction * movement;
                }

                // Wrap around if necessary
                computerPaddleStartIndex = (computerPaddleStartIndex + heartPoints.length) % heartPoints.length;
            }

            // Helper function to find the closest point index on the heart to given x, y
            function findClosestPointIndex(x, y) {
                let minDistance = Infinity;
                let closestIndex = 0;
                for (let i = 0; i < heartPoints.length; i++) {
                    let dx = x - heartPoints[i].x;
                    let dy = y - heartPoints[i].y;
                    let distance = dx * dx + dy * dy;
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                return closestIndex;
            }

            // Function to check if a circle (ball) intersects with a line segment
            function detectCircleLineSegmentIntersection(ball, prevBall, segment) {
                const x1 = segment.start.x;
                const y1 = segment.start.y;
                const x2 = segment.end.x;
                const y2 = segment.end.y;

                const dx = ball.x - prevBall.x;
                const dy = ball.y - prevBall.y;

                const fx = prevBall.x - x1;
                const fy = prevBall.y - y1;

                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - ball.radius * ball.radius;

                let discriminant = b * b - 4 * a * c;

                if (discriminant < 0) {
                    // No intersection
                    return null;
                }

                discriminant = Math.sqrt(discriminant);

                let t1 = (-b - discriminant) / (2 * a);
                let t2 = (-b + discriminant) / (2 * a);

                if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
                    let t = t1;
                    if (t1 < 0 || t1 > 1) t = t2;
                    if (t < 0 || t > 1) return null;

                    const collisionX = prevBall.x + dx * t;
                    const collisionY = prevBall.y + dy * t;

                    return { x: collisionX, y: collisionY };
                }

                return null;
            }

            // Function to retrieve all line segments of the paddle
            function getPaddleSegments(startIndex) {
                let segments = [];
                let sIndex = Math.floor(startIndex) % heartPoints.length;
                let eIndex = (sIndex + paddleLength) % heartPoints.length;

                if (sIndex < eIndex) {
                    for (let i = sIndex; i < eIndex; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[(i + 1) % heartPoints.length]
                        });
                    }
                } else {
                    // Wrap-around case
                    for (let i = sIndex; i < heartPoints.length - 1; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[i + 1]
                        });
                    }
                    segments.push({
                        start: heartPoints[heartPoints.length - 1],
                        end: heartPoints[0]
                    });
                    for (let i = 0; i < eIndex; i++) {
                        segments.push({
                            start: heartPoints[i],
                            end: heartPoints[i + 1]
                        });
                    }
                }

                return segments;
            }

            // Update ball position and handle collisions
            function updateBall() {
                if (gameEnding || gameOver || paused) {
                    // Continue moving the ball off-screen or do nothing if paused
                    if (!paused) {
                        ball.prevX = ball.x;
                        ball.prevY = ball.y;
                        // Accelerate the ball off-screen
                        if (gameEnding) {
                            let speedIncrease = 1.05; // Adjust acceleration factor as needed
                            ball.velocity.x *= speedIncrease;
                            ball.velocity.y *= speedIncrease;
                        }
                        ball.x += ball.velocity.x;
                        ball.y += ball.velocity.y;

                        // Check if the ball is completely off the screen
                        if (ball.x < -ball.radius || ball.x > canvas.width + ball.radius ||
                            ball.y < -ball.radius || ball.y > canvas.height + ball.radius) {
                            // End the game after the ball has flown off-screen
                            gameOver = true;
                            cancelAnimationFrame(animationFrameId);
                            displayGameOver();
                            // Remove 'playing' class to show cursor again
                            document.body.classList.remove('playing');
                            document.body.style.cursor = 'default'; // Ensure cursor is visible
                            console.log("Game over: Ball flew off-screen.");
                        }
                    }
                    return; // Exit the function to prevent further collision checks
                }

                // Store previous position
                ball.prevX = ball.x;
                ball.prevY = ball.y;

                // Move the ball
                ball.x += ball.velocity.x;
                ball.y += ball.velocity.y;

                // Check if the ball is outside the heart boundary
                let isCurrentlyOutside = !ctx.isPointInPath(heartPath, ball.x, ball.y);

                if (isCurrentlyOutside && !isBallOutside) {
                    // Ball has just moved outside - initiate game ending sequence
                    gameEnding = true;
                    console.log("Ball moved outside the heart boundary.");
                    // Determine game result in 2 paddle mode
                    if (twoPaddleMode) {
                        gameResult = isPlayerTurn ? "lose" : "win";
                        if (gameResult === "win") {
                            playerScore++;
                        } else if (gameResult === "lose") {
                            aiScore++;
                        }
                    }
                    return;
                }

                // Update isBallOutside flag
                isBallOutside = isCurrentlyOutside;

                // Continuous Collision Detection (CCD)
                let collisionDetected = false;
                let collisionPoint = null;
                let collidedSegment = null;

                // Determine whose paddle can cause collision
                let activePaddleStartIndex = twoPaddleMode ? (isPlayerTurn ? paddleStartIndex : computerPaddleStartIndex) : paddleStartIndex;

                let paddleSegments = getPaddleSegments(activePaddleStartIndex);

                for (let segment of paddleSegments) {
                    let intersection = detectCircleLineSegmentIntersection(ball, { x: ball.prevX, y: ball.prevY }, segment);
                    if (intersection) {
                        collisionDetected = true;
                        collisionPoint = intersection;
                        collidedSegment = segment;
                        break; // Exit loop after first collision
                    }
                }

                if (collisionDetected && collisionPoint && collidedSegment) {
                    // Calculate the normal based on the paddle segment
                    let normalVector = calculateNormal(collidedSegment);

                    // Reflect the velocity vector based on the normal vector
                    ball.velocity = reflectVelocity(ball.velocity, normalVector);

                    // Adjust the ball's position to be just outside the paddle
                    ball.x = collisionPoint.x + normalVector.x * (ball.radius + 1);
                    ball.y = collisionPoint.y + normalVector.y * (ball.radius + 1);

                    // Increase score
                    if (!twoPaddleMode) {
                        score++;
                    }
                    updateScoreboard();

                    // Increase ball speed slightly, ensuring it doesn't exceed MAX_BALL_SPEED
                    ball.speed = Math.min(ball.speed + 0.2, MAX_BALL_SPEED);
                    let speedRatio = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                    ball.velocity.x *= speedRatio;
                    ball.velocity.y *= speedRatio;

                    // Set paddle hit flag for visual feedback
                    isPaddleHit = true;

                    // Play sound if enabled
                    playHitSound();

                    // Switch turns in 2 paddle mode
                    if (twoPaddleMode) {
                        isPlayerTurn = !isPlayerTurn;
                    }
                }

                // If collision wasn't detected via CCD, check for discrete collision as a fallback
                if (!collisionDetected && isBallCollidingWithPaddle(activePaddleStartIndex)) {
                    let fallbackCollisionPoint = findCollisionPoint(activePaddleStartIndex);
                    if (fallbackCollisionPoint) {
                        let normalVector = { x: ball.x - fallbackCollisionPoint.x, y: ball.y - fallbackCollisionPoint.y };
                        ball.velocity = reflectVelocity(ball.velocity, normalVector);

                        // Move the ball slightly away from paddle
                        ball.x += ball.velocity.x * 2;
                        ball.y += ball.velocity.y * 2;

                        // Increase score
                        if (!twoPaddleMode) {
                            score++;
                        }
                        updateScoreboard();

                        // Increase ball speed slightly, ensuring it doesn't exceed MAX_BALL_SPEED
                        ball.speed = Math.min(ball.speed + 0.2, MAX_BALL_SPEED);
                        let speedRatioFallback = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                        ball.velocity.x *= speedRatioFallback;
                        ball.velocity.y *= speedRatioFallback;

                        // Set paddle hit flag for visual feedback
                        isPaddleHit = true;

                        // Play sound if enabled
                        playHitSound();

                        // Switch turns in 2 paddle mode
                        if (twoPaddleMode) {
                            isPlayerTurn = !isPlayerTurn;
                        }
                    }
                }

                // Draw tracers if enabled
                if (enableTracers) {
                    drawTracers();
                }
            }

            // Find the collision point between the ball and the paddle (discrete collision detection)
            function findCollisionPoint(startIndex) {
                let sIndex = Math.floor(startIndex) % heartPoints.length;
                let eIndex = (sIndex + paddleLength) % heartPoints.length;

                // Gather paddle points
                let paddlePoints = [];
                if (sIndex < eIndex) {
                    for (let i = sIndex; i <= eIndex; i++) {
                        paddlePoints.push(heartPoints[i % heartPoints.length]);
                    }
                } else {
                    for (let i = sIndex; i < heartPoints.length; i++) {
                        paddlePoints.push(heartPoints[i]);
                    }
                    for (let i = 0; i <= eIndex; i++) {
                        paddlePoints.push(heartPoints[i]);
                    }
                }

                // Find the closest paddle point to the ball
                let minDistance = Infinity;
                let closestPoint = null;
                for (let point of paddlePoints) {
                    let distance = Math.hypot(ball.x - point.x, ball.y - point.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = point;
                    }
                }

                // If the closest point is within collision range, return it
                if (closestPoint && minDistance <= ball.radius + (ctx.lineWidth / 2)) {
                    return closestPoint;
                }

                return null;
            }

            // Check if ball is colliding with paddle
            function isBallCollidingWithPaddle(startIndex) {
                return findCollisionPoint(startIndex) !== null;
            }

            // Draw ball
            function drawBall() {
                ctx.save();
                ctx.translate(ball.x, ball.y);

                // Apply pulsing effect if in pre-game pulsing state
                if (preGamePulsing) {
                    let elapsedTime = performance.now() - preGamePulseStartTime;
                    let scale = 1 + 0.3 * Math.sin((elapsedTime / 200) * Math.PI);
                    ctx.scale(scale, scale);
                }

                ctx.beginPath();
                ctx.arc(0, 0, ball.radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'magenta';
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'magenta';
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow

                ctx.restore();
            }

            // Draw tracers
            function drawTracers() {
                // Fade previous tracers slightly
                tracerCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                tracerCtx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw ball tracer
                tracerCtx.save();
                tracerCtx.translate(ball.x, ball.y);
                tracerCtx.beginPath();
                tracerCtx.arc(0, 0, ball.radius, 0, 2 * Math.PI);
                tracerCtx.fillStyle = 'rgba(255, 0, 255, 0.5)'; // Magenta with transparency
                tracerCtx.fill();
                tracerCtx.restore();

                // Draw paddle tracers
                // Player paddle
                tracerCtx.beginPath();
                tracerCtx.strokeStyle = 'rgba(255, 0, 255, 0.5)'; // Magenta with transparency
                tracerCtx.lineWidth = paddleThickness;
                tracerCtx.lineJoin = 'round'; // Ensure rounded joins
                drawPaddleSegmentForTracers(paddleStartIndex, tracerCtx);
                tracerCtx.stroke();

                // Computer paddle
                if (twoPaddleMode) {
                    tracerCtx.beginPath();
                    tracerCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; // Cyan with transparency
                    tracerCtx.lineWidth = paddleThickness;
                    tracerCtx.lineJoin = 'round'; // Ensure rounded joins
                    drawPaddleSegmentForTracers(computerPaddleStartIndex, tracerCtx);
                    tracerCtx.stroke();
                }
            }

            // Modified function to prevent spikes in tracers and match paddles exactly
            function drawPaddleSegmentForTracers(startIndex, context) {
                let sIndex = Math.floor(startIndex) % heartPoints.length;
                let eIndex = (sIndex + paddleLength) % heartPoints.length;

                let indices = [];
                if (sIndex <= eIndex) {
                    for (let i = sIndex; i <= eIndex; i++) {
                        indices.push(i % heartPoints.length);
                    }
                } else {
                    for (let i = sIndex; i < heartPoints.length; i++) {
                        indices.push(i);
                    }
                    for (let i = 0; i <= eIndex; i++) {
                        indices.push(i);
                    }
                }

                context.moveTo(heartPoints[indices[0]].x, heartPoints[indices[0]].y);

                for (let i = 1; i < indices.length; i++) {
                    let currentIndex = indices[i];
                    context.lineTo(heartPoints[currentIndex].x, heartPoints[currentIndex].y);
                }
            }

            // Update scoreboard
            function updateScoreboard() {
                if (twoPaddleMode) {
                    document.querySelector('#scoreboard .score').innerText = `You: ${playerScore}  AI: ${aiScore}`;
                } else {
                    document.querySelector('#scoreboard .score').innerText = `score: ${score}`;
                }
            }

            // Pause the game
            function pauseGame() {
                paused = true;
                cancelAnimationFrame(animationFrameId);
                pausedOverlay.style.display = 'flex';
            }

            // Resume the game
            function resumeGame() {
                paused = false;
                pausedOverlay.style.display = 'none';
                lastFrameTime = performance.now(); // Reset the lastFrameTime to avoid large deltaTime
                gameLoop(); // Restart the game loop
            }

            // Display game over message
            function displayGameOver() {
                let gameOverMessage = "game over";
                if (twoPaddleMode) {
                    if (gameResult === "win") {
                        gameOverMessage = "winner!";
                    } else if (gameResult === "lose") {
                        gameOverMessage = "gotcha";
                    }
                }

                document.getElementById('gameOver').innerText = gameOverMessage;
                document.getElementById('gameOver').style.display = 'block';

                // Update scoreboard
                updateScoreboard();

                // Check if best of 3 is over
                if (twoPaddleMode) {
                    if (playerScore >= gamesToWin || aiScore >= gamesToWin) {
                        // Best of 3 over, declare overall winner
                        if (playerScore > aiScore) {
                            document.getElementById('gameOver').innerText = "You win the match!";
                        } else {
                            document.getElementById('gameOver').innerText = "AI wins the match!";
                        }
                        document.getElementById('restartButton').innerText = 'reset';
                    } else {
                        // Next game
                        document.getElementById('restartButton').innerText = 'next game';
                    }
                } else {
                    // For single paddle mode
                    document.getElementById('restartButton').innerText = 'restart';
                }

                document.getElementById('restartButton').style.display = 'block';

                // Ensure cursor is visible
                document.body.style.cursor = 'default';
            }

            // Main game loop with deltaTime for smooth movement
            let lastFrameTime = performance.now();
            function gameLoop(currentTime = performance.now()) {
                if (gameOver || paused) return;

                // Calculate deltaTime in seconds
                let deltaTime = (currentTime - lastFrameTime) / 1000;
                lastFrameTime = currentTime;

                if (enableTracers) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(tracerCanvas, 0, 0);
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

                drawHeart();
                drawPaddle();
                updateScoreboard();

                // Handle pre-game pulsing
                if (preGamePulsing) {
                    drawBall();
                    if (currentTime - preGamePulseStartTime >= 2000) {
                        preGamePulsing = false;
                        lastFrameTime = performance.now(); // Reset time to prevent jump
                    }
                } else {
                    updateBall();
                    drawBall();
                }

                // Handle keyboard input with deltaTime
                updatePaddleKeyboard(deltaTime);

                // Handle touch/mouse control towards target paddle index
                updatePaddleTowardsTarget(deltaTime);

                // Update computer paddle if in 2 Paddle Mode
                if (twoPaddleMode) {
                    updateComputerPaddle(deltaTime);
                }

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // Select buttons
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');

            // Add event listeners
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Define startGame and restartGame normally
            function startGame() {
                console.log("Start Game button clicked.");
                // Hide start button
                startButton.style.display = 'none';
                // Add 'playing' class to hide cursor
                document.body.classList.add('playing');
                document.body.style.cursor = 'none';
                // Reset variables
                score = 0;
                gameResult = "";
                gameStarted = true;
                gameOver = false;
                gameEnding = false;
                paused = false;
                ball.speed = parseFloat(puckSpeedSlider.value); // Use slider value
                paddleSpeed = parseFloat(paddleSpeedSlider.value);
                keyboardMoveSpeed = paddleSpeed;
                aiSkillLevel = parseInt(aiSkillLevelSlider.value);
                enableTracers = tracersToggle.checked;
                setBallStartingPosition();
                initializeBallVelocity(); // Set initial velocity
                updateScoreboard();
                // Reset lastFrameTime for consistent deltaTime
                lastFrameTime = performance.now();
                // Hide paused overlay if visible
                pausedOverlay.style.display = 'none';
                // Initialize target paddle index
                targetPaddleStartIndex = paddleStartIndex;

                // Start pre-game pulsing
                preGamePulsing = true;
                preGamePulseStartTime = performance.now();

                // Set turn to computer if in 2 Paddle Mode
                if (twoPaddleMode) {
                    isPlayerTurn = false;
                }

                // Clear tracers
                tracerCtx.clearRect(0, 0, canvas.width, canvas.height);

                // Start game loop
                gameLoop();
            }

            function restartGame() {
                console.log("Restart Game button clicked.");
                // Hide game over and restart button
                document.getElementById('gameOver').style.display = 'none';
                restartButton.style.display = 'none';
                // Add 'playing' class to hide cursor
                document.body.classList.add('playing');
                document.body.style.cursor = 'none';

                // If best of 3 is over and button says 'reset', reset scores
                if (twoPaddleMode && (playerScore >= gamesToWin || aiScore >= gamesToWin) && restartButton.innerText === 'reset') {
                    playerScore = 0;
                    aiScore = 0;
                    updateScoreboard();
                }

                // Reset variables
                gameResult = "";
                gameStarted = true;
                gameOver = false;
                gameEnding = false;
                paused = false;
                ball.speed = parseFloat(puckSpeedSlider.value); // Use slider value
                paddleSpeed = parseFloat(paddleSpeedSlider.value);
                keyboardMoveSpeed = paddleSpeed;
                aiSkillLevel = parseInt(aiSkillLevelSlider.value);
                enableTracers = tracersToggle.checked;
                setBallStartingPosition();
                initializeBallVelocity(); // Set initial velocity
                // Reset lastFrameTime for consistent deltaTime
                lastFrameTime = performance.now();
                // Hide paused overlay if visible
                pausedOverlay.style.display = 'none';
                // Initialize target paddle index
                targetPaddleStartIndex = paddleStartIndex;

                // Start pre-game pulsing
                preGamePulsing = true;
                preGamePulseStartTime = performance.now();

                // Set turn to computer if in 2 Paddle Mode
                if (twoPaddleMode) {
                    isPlayerTurn = false;
                }

                // Clear tracers
                tracerCtx.clearRect(0, 0, canvas.width, canvas.height);

                // Start game loop
                gameLoop();
            }

            // Show start button
            startButton.style.display = 'block';
            console.log("Start Game button displayed.");

            // Options Menu Logic

            menuIcon.addEventListener('click', () => {
                openMenu();
            });

            menuCloseButton.addEventListener('click', () => {
                closeMenu();
            });

            function openMenu() {
                menuOpen = true;
                menuOverlay.style.display = 'block';
                document.body.style.cursor = 'default'; // Show cursor in menu
                if (gameStarted && !paused) {
                    pauseGame();
                }
            }

            function closeMenu() {
                menuOpen = false;
                menuOverlay.style.display = 'none';
                if (!gameOver && !gameEnding) {
                    document.body.style.cursor = 'none'; // Hide cursor when returning to game
                }
                if (gameStarted && paused) {
                    resumeGame();
                }
            }

            // Event listeners for Options
            puckSpeedSlider.addEventListener('input', () => {
                ball.speed = parseFloat(puckSpeedSlider.value);
                let speedRatio = ball.speed / Math.hypot(ball.velocity.x, ball.velocity.y);
                ball.velocity.x *= speedRatio;
                ball.velocity.y *= speedRatio;
            });

            paddleSpeedSlider.addEventListener('input', () => {
                paddleSpeed = parseFloat(paddleSpeedSlider.value);
                keyboardMoveSpeed = paddleSpeed;
            });

            nightModeToggle.addEventListener('change', () => {
                if (nightModeToggle.checked) {
                    document.body.classList.add('nightmode');
                    heartOutlineColor = '#fff';
                } else {
                    document.body.classList.remove('nightmode');
                    heartOutlineColor = '#aaa'; // Light grey for visibility on white background
                }
                if (gameStarted) {
                    restartGame();
                }
            });

            // Set initial night mode based on checkbox
            if (nightModeToggle.checked) {
                document.body.classList.add('nightmode');
                heartOutlineColor = '#fff';
            } else {
                document.body.classList.remove('nightmode');
                heartOutlineColor = '#aaa'; // Light grey for visibility on white background
            }

            // Two Paddle Mode Toggle
            twoPaddleModeToggle.addEventListener('change', () => {
                twoPaddleMode = twoPaddleModeToggle.checked;
                if (gameStarted) {
                    // Reset scores
                    playerScore = 0;
                    aiScore = 0;
                    updateScoreboard();
                    restartGame();
                }
            });

            aiSkillLevelSlider.addEventListener('input', () => {
                aiSkillLevel = parseInt(aiSkillLevelSlider.value);
                if (gameStarted) {
                    restartGame();
                }
            });

            tracersToggle.addEventListener('change', () => {
                enableTracers = tracersToggle.checked;
                if (enableTracers) {
                    tracerCtx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            // Sound Logic
            volumeSlider.addEventListener('input', () => {
                hitSounds.forEach(sound => {
                    sound.volume = parseFloat(volumeSlider.value);
                });
            });

            soundToggle.addEventListener('change', () => {
                if (!soundToggle.checked) {
                    hitSounds.forEach(sound => {
                        sound.muted = true;
                    });
                } else {
                    hitSounds.forEach(sound => {
                        sound.muted = false;
                    });
                }
            });

            function playHitSound() {
                if (soundToggle.checked) {
                    let sound = hitSounds[hitSoundIndex];
                    sound.currentTime = 0;
                    sound.play();
                    hitSoundIndex = (hitSoundIndex + 1) % hitSounds.length;
                }
            }
        });
    </script>
</body>
</html>

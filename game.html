<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Viewport meta tag for responsive design -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart Catch Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      overflow: hidden;
      touch-action: none;
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="120" width="120"><text y="90" x="60" text-anchor="middle" font-size="90">🩷</text></svg>') 60 60, auto;
      position: relative;
      height: 100vh;
      width: 100vw;
      transition: cursor 0.1s; /* Smooth transition for cursor change */
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #f0f0f0;
      z-index: 5; /* Positioned below gameStats */
    }
    #heartCursor {
      position: absolute;
      pointer-events: none;
      display: none;
      z-index: 10;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 6vh;
      color: magenta;
      display: none;
      z-index: 15;
      margin-bottom: 2vh; /* Adds space between game over and restart */
      pointer-events: none;
    }
    #startButton, #restartButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: transparent;
      color: magenta;
      padding: 20px 40px;
      border: 3px solid magenta;
      border-radius: 5px;
      cursor: inherit; /* Inherit cursor from body */
      font-family: 'Press Start 2P', cursive;
      font-size: 2rem;
      display: none;
      user-select: none;
      z-index: 15;
    }
    #startButton:hover, #restartButton:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    #gameStats {
      position: absolute;
      top: 5%;
      left: 5%;
      color: magenta;
      z-index: 10; /* Positioned above the canvas */
      text-align: left;
      font-family: 'Press Start 2P', cursive;
      pointer-events: none; /* Prevents interference with gameplay */
    }
    #title {
      font-size: 4vh;
      word-wrap: break-word; /* Ensure text wraps if too long */
      max-width: 90vw; /* Prevent overflow by limiting width */
    }
    #stats {
      font-size: 2vh;
      margin-top: 1vh; /* Blank line */
    }
    #controls {
      margin-top: 1vh; /* Blank line */
      display: flex;
      gap: 10px;
    }
    #pauseText {
      display: inline-block;
      padding: 5px 10px;
      border: 2px solid magenta;
      color: magenta;
      cursor: inherit; /* Inherit cursor from body */
      font-size: 1.5vh;
      font-family: 'Press Start 2P', cursive;
      user-select: none;
      pointer-events: none; /* Prevents interference with gameplay */
    }
    #waveOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: magenta;
      font-size: 5vh;
      opacity: 0;
      transition: opacity 1s;
      z-index: 20;
      pointer-events: none;
    }

    /* Media Query for Mobile Devices */
    @media only screen and (max-width: 768px) {
      #title {
        font-size: 2vh; /* Half of 4vh */
        max-width: 90vw; /* Ensure it doesn't exceed viewport */
      }
      #stats {
        font-size: 1vh; /* Half of 2vh */
      }
      #gameOver {
        font-size: 3vh; /* Half of 6vh */
      }
      #startButton, #restartButton {
        font-size: 1rem; /* Half of 2rem */
        padding: 10px 20px; /* Half padding */
      }
      #pauseText {
        font-size: 0.75vh; /* Half of 1.5vh */
      }
      #waveOverlay {
        font-size: 2.5vh; /* Half of 5vh */
      }
    }
  </style>
</head>
<body>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Heart cursor for mobile devices -->
  <img id="heartCursor" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg'><text y='50%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='100%'>🩷</text></svg>" alt="Heart Cursor">
  
  <!-- Game Statistics and Controls -->
  <div id="gameStats">
    <div id="title">spread love</div>
    <div id="stats" style="line-height: 1.5em;">
      score: 0<br>
      lives left: 3<br>
      wave: 1
    </div>
    <div id="controls">
      <!-- Removed pause and reset buttons as per request -->
    </div>
  </div>
  
  <!-- Start and Restart Buttons -->
  <div id="startButton" onclick="startGame()">start game</div>
  <div id="gameOver">game over</div>
  <div id="restartButton" onclick="restartGame()" style="margin-top: 20px;">restart</div>
  
  <!-- Wave Overlay -->
  <div id="waveOverlay">wave 1!</div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const heartCursor = document.getElementById('heartCursor');
    const waveOverlay = document.getElementById('waveOverlay');

    // Define cursor URLs
    const originalCursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"120\" width=\"120\"><text y=\"90\" x=\"60\" text-anchor=\"middle\" font-size=\"90\">🩷</text></svg>') 60 60, auto";
    const clickCursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"120\" width=\"120\"><text y=\"90\" x=\"60\" text-anchor=\"middle\" font-size=\"90\">💖</text></svg>') 60 60, auto";

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    let faceSize;
    let cursorCollisionRadius;
    let score = 0;
    let missed = 0;
    let maxMissed = 3;
    let entities = [];
    let lastTime = Date.now();
    let gameOver = false;
    let isTouching = false;
    let touchX = undefined;
    let touchY = undefined;

    let waveNumber = 1;
    let speedMultiplier = 0.8; // Start a bit slower
    let waveSpawnInterval = 1000;
    let lastWaveSpawnTime = Date.now();
    let isPaused = false;
    let animationFrameId;

    function resizeGame() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      faceSize = Math.min(width, height) / 10; // Increased size by 50%
      faceSize = Math.max(Math.min(faceSize, 90), 30); // Adjusted max size to 90 to accommodate increased faceSize

      heartCursor.style.width = faceSize * 2 + 'px';
      heartCursor.style.height = faceSize * 2 + 'px';
      heartCursor.style.marginLeft = -faceSize + 'px';
      heartCursor.style.marginTop = -faceSize + 'px';

      cursorCollisionRadius = faceSize;
    }
    resizeGame();

    function isMobileDevice() {
      return typeof window.orientation !== 'undefined' || navigator.userAgent.indexOf('IEMobile') !== -1;
    }

    if (isMobileDevice()) {
      document.body.style.cursor = 'none';
    } else {
      heartCursor.style.display = 'none';
    }

    class Entity {
      constructor(x, y, vx, vy, isSad) {
        this.size = faceSize;
        this.x = x;
        this.y = y;
        this.vx = vx * speedMultiplier;
        this.vy = vy * speedMultiplier;
        this.isSad = isSad;
        this.hit = false;
      }

      update(delta) {
        if (this.isSad) {
          // Touch avoidance logic
          if (typeof touchX !== 'undefined' && typeof touchY !== 'undefined') {
            let dx = this.x - touchX;
            let dy = this.y - touchY;
            let distance = Math.hypot(dx, dy);
            let detectionRadius = 200;

            if (distance < detectionRadius) {
              let nx = dx / distance;
              let ny = dy / distance;
              let avoidSpeed = ((detectionRadius - distance) / detectionRadius) * 2 * speedMultiplier;
              this.vx += nx * avoidSpeed * delta;
              this.vy += ny * avoidSpeed * delta;
            }
          }

          // Add gravity
          const gravity = 0.2 * speedMultiplier;
          this.vy += gravity * delta;

          // Increase erraticness
          this.vx += (Math.random() - 0.5) * 1.2 * delta * speedMultiplier; // Further increased randomness
          this.vy += (Math.random() - 0.5) * 0.8 * delta * speedMultiplier; // Further increased randomness

          // Increase max speed
          let maxSpeed = 10 * speedMultiplier; // Increased max speed to accommodate higher randomness
          let speed = Math.hypot(this.vx, this.vy);
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }

          // Update position
          this.x += this.vx * delta;
          this.y += this.vy * delta;

          // Prevent faces from staying at the top
          if (this.y < this.size / 2 + 10) {
            this.vy = Math.abs(this.vy) + 1 * speedMultiplier;
            this.y = this.size / 2 + 10;
          }

          // Boundary checks
          if (this.x < this.size / 2) {
            this.x = this.size / 2;
            this.vx = -this.vx;
          } else if (this.x > width - this.size / 2) {
            this.x = width - this.size / 2;
            this.vx = -this.vx;
          }

          if (this.y > height + this.size) {
            missed++;
            this.hit = true;
          }
        } else {
          // Happy faces movement
          // Increase erraticness
          this.vx += (Math.random() - 0.5) * 0.6 * delta * speedMultiplier; // Increased randomness
          this.vy += (Math.random() - 0.5) * 0.6 * delta * speedMultiplier; // Increased randomness

          // Increase max speed
          let maxSpeed = 9 * speedMultiplier; // Increased max speed to accommodate higher randomness
          let speed = Math.hypot(this.vx, this.vy);
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }

          // Update position
          this.x += this.vx * delta;
          this.y += this.vy * delta;

          // Boundary checks
          if (this.x < this.size / 2) {
            this.x = this.size / 2;
            this.vx = -this.vx;
          } else if (this.x > width - this.size / 2) {
            this.x = width - this.size / 2;
            this.vx = -this.vx;
          }

          if (this.y < -this.size) {
            this.hit = true;
          }
        }
      }

      getFace() {
        if (!this.isSad) {
          return '😍';
        } else {
          const progress = this.y / height;
          if (progress < 0.25) {
            return '😐';
          } else if (progress < 0.5) {
            return '🙁';
          } else if (progress < 0.75) {
            return '😢';
          } else {
            return '😱';
          }
        }
      }

      draw() {
        ctx.font = `${this.size}px "Press Start 2P", cursive`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'magenta';
        ctx.fillText(this.getFace(), this.x, this.y);
      }
    }

    function showWaveOverlay(waveNumber) {
      waveOverlay.textContent = `wave ${waveNumber}!`;
      waveOverlay.style.opacity = '1';
      setTimeout(() => {
        waveOverlay.style.opacity = '0';
      }, 2000);
    }

    function spawnEntity() {
      const size = faceSize;
      const x = Math.random() * (width - size) + size / 2;
      const y = -size;
      const vx = (Math.random() - 0.5) * 2.5 * speedMultiplier; // Increased horizontal velocity range
      const vy = (Math.random() * 3.0 + 4.0) * speedMultiplier; // Further increased vy
      entities.push(new Entity(x, y, vx, vy, true));
    }

    function handleTouchStart(e) {
      isTouching = true;
      const touch = e.touches[0];
      touchX = touch.clientX;
      touchY = touch.clientY;
      heartCursor.style.display = 'block';
      heartCursor.style.left = touchX + 'px';
      heartCursor.style.top = touchY + 'px';

      entities.forEach(entity => {
        const dx = entity.x - touchX;
        const dy = entity.y - touchY;
        const distance = Math.hypot(dx, dy);
        if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
          entity.isSad = false;
          entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
          entity.vy = -(Math.random() * 5 + 5) * speedMultiplier;
          score++;
          updateGameStats();

          // Check if it's time to increase the wave
          if (score % 10 === 0) {
            waveNumber++;
            speedMultiplier += 0.1;
            waveSpawnInterval = Math.max(200, waveSpawnInterval - 50);
            updateGameStats();
            showWaveOverlay(waveNumber);
          }
        }
      });
    }

    function handleTouchMove(e) {
      const touch = e.touches[0];
      touchX = touch.clientX;
      touchY = touch.clientY;
      heartCursor.style.left = touchX + 'px';
      heartCursor.style.top = touchY + 'px';
    }

    function handleTouchEnd(e) {
      isTouching = false;
      heartCursor.style.display = 'none';
      touchX = undefined;
      touchY = undefined;
    }

    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);

    canvas.addEventListener('mousedown', function(e) {
      // Change cursor to 💖
      if (!isMobileDevice()) {
        document.body.style.cursor = clickCursor;
        setTimeout(() => {
          document.body.style.cursor = originalCursor;
        }, 200); // Change back after 200ms
      }

      touchX = e.clientX;
      touchY = e.clientY;

      entities.forEach(entity => {
        const dx = entity.x - touchX;
        const dy = entity.y - touchY;
        const distance = Math.hypot(dx, dy);
        if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
          entity.isSad = false;
          entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
          entity.vy = -(Math.random() * 5 + 5) * speedMultiplier;
          score++;
          updateGameStats();

          // Check if it's time to increase the wave
          if (score % 10 === 0) {
            waveNumber++;
            speedMultiplier += 0.1;
            waveSpawnInterval = Math.max(200, waveSpawnInterval - 50);
            updateGameStats();
            showWaveOverlay(waveNumber);
          }
        }
      });
    });

    canvas.addEventListener('mousemove', function(e) {
      if (isTouching) return;
      touchX = e.clientX;
      touchY = e.clientY;
    });

    canvas.addEventListener('mouseleave', function() {
      touchX = undefined;
      touchY = undefined;
    });

    function update() {
      if (gameOver || isPaused) return;

      const now = Date.now();
      const delta = (now - lastTime) / 16;

      ctx.clearRect(0, 0, width, height);

      if (now - lastWaveSpawnTime > waveSpawnInterval) {
        spawnEntity();
        lastWaveSpawnTime = now;
      }

      entities.forEach(entity => {
        entity.update(delta);
        entity.draw();
      });

      entities = entities.filter(entity => !entity.hit);

      if (missed >= maxMissed) {
        endGame();
      }

      lastTime = now;
      animationFrameId = requestAnimationFrame(update);
    }

    function updateGameStats() {
      document.getElementById('stats').innerHTML = `
        score: ${score}<br>
        lives left: ${maxMissed - missed}<br>
        wave: ${waveNumber}
      `;
    }

    function endGame() {
      gameOver = true;
      document.getElementById('gameOver').style.display = 'block';
      document.getElementById('restartButton').style.display = 'block';
    }

    function startGame() {
      document.getElementById('startButton').style.display = 'none';
      lastTime = Date.now(); // Reset lastTime
      lastWaveSpawnTime = Date.now(); // Reset lastWaveSpawnTime
      gameOver = false;
      showWaveOverlay(waveNumber);
      update();
    }

    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('restartButton').style.display = 'none';
      score = 0;
      missed = 0;
      waveNumber = 1;
      entities = [];
      speedMultiplier = 0.8;
      waveSpawnInterval = 1000;
      gameOver = false;
      lastTime = Date.now(); // Reset lastTime
      lastWaveSpawnTime = Date.now(); // Reset lastWaveSpawnTime
      updateGameStats();
      showWaveOverlay(waveNumber);
      update();
    }

    // Ensure the game resizes properly when the window size changes
    window.addEventListener('resize', () => {
      resizeGame();
    });

    // Initialize the game stats
    updateGameStats();

    // Show the start button when the page loads
    document.getElementById('startButton').style.display = 'block';
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Heart Touch Game</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    touch-action: none; /* Prevent default touch behaviors */
  }
  canvas {
    display: block;
    background-color: #f0f0f0;
  }
  #heartCursor {
    position: absolute;
    pointer-events: none; /* Allow clicks through the image */
    display: none;
  }
  #gameOver {
    position: absolute;
    top: 40%;
    width: 100%;
    text-align: center;
    font-size: 60px;
    font-family: Arial, sans-serif;
    color: red;
    display: none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<img id="heartCursor" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg'><text y='60%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='100%'>‚ù§Ô∏è</text></svg>" alt="Heart Cursor">
<div id="gameOver">Game Over</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const heartCursor = document.getElementById('heartCursor');

let width, height;
let faceSize;
let cursorCollisionRadius;
let score = 0;
let missed = 0;
let maxMissed = 3;
let entities = [];
let lastTime = Date.now();
let gameOver = false;
let spawnInterval = 2000; // Time between spawns in milliseconds
let lastSpawnTime = Date.now();
let spawnAcceleration = 0.98; // Spawn interval multiplier to increase spawn rate over time
let isTouching = false;
let touchX = 0;
let touchY = 0;

function resizeCanvas() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;

  // Set face size based on screen size
  faceSize = Math.min(width, height) / 5;

  // Adjust heart cursor size
  heartCursor.style.width = faceSize + 'px';
  heartCursor.style.height = faceSize + 'px';
  heartCursor.style.marginLeft = -faceSize / 2 + 'px';
  heartCursor.style.marginTop = -faceSize / 2 + 'px';

  // Adjust collision radius
  cursorCollisionRadius = faceSize / 2;
}
resizeCanvas(); // Call once at the beginning

class Entity {
  constructor(x, y, vx, vy, isSad) {
    this.size = faceSize;
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.isSad = isSad;
    this.hit = false;
    this.angle = Math.random() * Math.PI * 2;
    this.angularSpeed = (Math.random() - 0.5) * 0.1;
  }

  update(delta) {
    // Update position with more complex movement
    this.angle += this.angularSpeed * delta;
    this.x += Math.cos(this.angle) * this.vx * delta;
    this.y += this.vy * delta;

    // Keep entities within the canvas horizontally
    if (this.x < this.size / 2) {
      this.x = this.size / 2;
      this.angle = Math.PI - this.angle;
    } else if (this.x > width - this.size / 2) {
      this.x = width - this.size / 2;
      this.angle = Math.PI - this.angle;
    }

    if (this.isSad && this.y > height + this.size) {
      missed++;
      this.hit = true; // Mark as processed
    }

    if (!this.isSad && this.y + this.size < 0) {
      this.hit = true; // Mark as processed
    }
  }

  getFace() {
    if (!this.isSad) {
      return 'üòç'; // Heart eyes emoji
    } else {
      // Change face based on position
      const progress = this.y / height;
      if (progress < 0.25) {
        return 'üòê'; // Neutral
      } else if (progress < 0.5) {
        return 'üôÅ'; // Sad
      } else if (progress < 0.75) {
        return 'üò¢'; // Crying
      } else {
        return 'üò±'; // Scared
      }
    }
  }

  draw() {
    ctx.font = faceSize + 'px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.getFace(), this.x, this.y);
  }
}

function spawnEntity() {
  const size = faceSize; // Same as entity size
  const x = Math.random() * (width - size) + size / 2;
  const y = -size;
  const vx = Math.random() * 1 + 1; // Speed adjustments
  const vy = Math.random() * 1 + 1;
  entities.push(new Entity(x, y, vx, vy, true));
}

function handleTouchStart(e) {
  isTouching = true;
  const touch = e.touches[0];
  touchX = touch.clientX;
  touchY = touch.clientY;
  heartCursor.style.display = 'block';
  heartCursor.style.left = touchX + 'px';
  heartCursor.style.top = touchY + 'px';

  entities.forEach(entity => {
    const dx = entity.x - touchX;
    const dy = entity.y - touchY;
    const distance = Math.hypot(dx, dy);
    if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
      entity.isSad = false;
      entity.vx = 0; // Stop horizontal movement
      entity.vy = -(Math.random() * 5 + 5); // Increased upward speed
      score++;
    }
  });
}

function handleTouchMove(e) {
  const touch = e.touches[0];
  touchX = touch.clientX;
  touchY = touch.clientY;
  heartCursor.style.left = touchX + 'px';
  heartCursor.style.top = touchY + 'px';
}

function handleTouchEnd(e) {
  isTouching = false;
  heartCursor.style.display = 'none';
}

canvas.addEventListener('touchstart', handleTouchStart);
canvas.addEventListener('touchmove', handleTouchMove);
canvas.addEventListener('touchend', handleTouchEnd);

// Fallback for mouse input on desktop
canvas.addEventListener('mousedown', function(e) {
  touchX = e.clientX;
  touchY = e.clientY;
  heartCursor.style.display = 'block';
  heartCursor.style.left = touchX + 'px';
  heartCursor.style.top = touchY + 'px';

  entities.forEach(entity => {
    const dx = entity.x - touchX;
    const dy = entity.y - touchY;
    const distance = Math.hypot(dx, dy);
    if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
      entity.isSad = false;
      entity.vx = 0;
      entity.vy = -(Math.random() * 5 + 5);
      score++;
    }
  });
});

canvas.addEventListener('mousemove', function(e) {
  if (isTouching) return; // Ignore mouse move during touch
  touchX = e.clientX;
  touchY = e.clientY;
  heartCursor.style.left = touchX + 'px';
  heartCursor.style.top = touchY + 'px';
});

canvas.addEventListener('mouseup', function(e) {
  heartCursor.style.display = 'none';
});

function update() {
  if (gameOver) return;

  const now = Date.now();
  const delta = (now - lastTime) / 16; // Roughly 60fps

  ctx.clearRect(0, 0, width, height);

  entities.forEach(entity => {
    entity.update(delta);
    entity.draw();
  });

  // Remove entities that have been processed
  entities = entities.filter(entity => !entity.hit);

  // Spawn new entity if time has passed
  if (now - lastSpawnTime > spawnInterval) {
    spawnEntity();
    lastSpawnTime = now;
    // Increase spawn rate over time
    spawnInterval *= spawnAcceleration;
    if (spawnInterval < 500) {
      spawnInterval = 500; // Minimum spawn interval
    }
  }

  // Draw score and lives left
  ctx.fillStyle = 'black';
  ctx.font = '30px Arial';
  ctx.fillText('Score: ' + score, 20, 40);
  ctx.fillText('Lives Left: ' + (maxMissed - missed), 20, 80);

  if (missed >= maxMissed) {
    endGame();
  }

  lastTime = now;
  requestAnimationFrame(update);
}

function endGame() {
  gameOver = true;
  document.getElementById('gameOver').style.display = 'block';
}

update(); // Start the game loop
</script>
</body>
</html>

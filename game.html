<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Viewport meta tag for responsive design -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart Catch Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      overflow: hidden;
      touch-action: none;
      cursor: none; /* Hide the default cursor */
      position: relative;
      height: 100vh;
      width: 100vw;
      transition: background-color 0.5s;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #f0f0f0;
      z-index: 5; /* Positioned below gameStats */
    }
    /* Custom Cursor */
    #customCursor {
      position: absolute;
      pointer-events: none;
      z-index: 1000;
      width: 60px; /* Original size */
      height: 60px;
      transform: translate(-50%, -50%) scale(1);
      transition: transform 0.2s ease;
      font-size: 60px;
      line-height: 60px;
      text-align: center;
      user-select: none;
      opacity: 1;
    }
    /* Active state for cursor animation */
    #customCursor.active {
      transform: translate(-50%, -50%) scale(1.75); /* Scale up by 75% (1.75x) */
    }
    /* Big Heart for Mobile Taps */
    .big-heart {
      position: absolute;
      pointer-events: none;
      z-index: 1001; /* Above the custom cursor */
      opacity: 1;
      transition: opacity 0.5s, transform 0.5s;
      transform: translate(-50%, -50%) scale(1);
      user-select: none;
    }
    .big-heart.animate {
      opacity: 0;
      transform: translate(-50%, -50%) scale(1.5); /* Scale up further during animation */
    }
    #heartCursor {
      position: absolute;
      pointer-events: none;
      display: none; /* Hidden by default */
      z-index: 10;
      width: 60px; /* Original size */
      height: 60px;
      transform: translate(-50%, -50%) scale(1);
      transition: transform 0.2s ease;
      font-size: 60px;
      line-height: 60px;
      text-align: center;
      user-select: none;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 6vh;
      color: magenta;
      display: none;
      z-index: 15;
      margin-bottom: 2vh; /* Adds space between game over and restart */
      pointer-events: none;
    }
    #startButton, #restartButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: transparent;
      color: magenta;
      padding: 20px 40px;
      border: 3px solid magenta;
      border-radius: 5px;
      cursor: pointer; /* Show pointer cursor for buttons */
      font-family: 'Press Start 2P', cursive;
      font-size: 2rem;
      display: none;
      user-select: none;
      z-index: 15;
    }
    #startButton:hover, #restartButton:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    #gameStats {
      position: absolute;
      top: 5%;
      left: 5%;
      color: magenta;
      z-index: 10; /* Positioned above the canvas */
      text-align: left;
      font-family: 'Press Start 2P', cursive;
      pointer-events: none; /* Prevents interference with gameplay */
    }
    #title {
      font-size: 4vh;
      word-wrap: break-word; /* Ensure text wraps if too long */
      max-width: 90vw; /* Prevent overflow by limiting width */
    }
    #stats {
      font-size: 2vh;
      margin-top: 1vh; /* Blank line */
    }
    #controls {
      margin-top: 1vh; /* Blank line */
      display: flex;
      gap: 10px;
    }
    #pauseText {
      display: inline-block;
      padding: 5px 10px;
      border: 2px solid magenta;
      color: magenta;
      cursor: inherit; /* Inherit cursor from body */
      font-size: 1.5vh;
      font-family: 'Press Start 2P', cursive;
      user-select: none;
      pointer-events: none; /* Prevents interference with gameplay */
    }
    #waveOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: magenta;
      font-size: 5vh;
      opacity: 0;
      transition: opacity 1s;
      z-index: 20;
      pointer-events: none;
    }

    /* Media Query for Mobile Devices */
    @media only screen and (max-width: 768px) {
      #title {
        font-size: 2vh; /* Half of 4vh */
        max-width: 90vw; /* Ensure it doesn't exceed viewport */
      }
      #stats {
        font-size: 1vh; /* Half of 2vh */
      }
      #gameOver {
        font-size: 3vh; /* Half of 6vh */
      }
      #startButton, #restartButton {
        font-size: 1rem; /* Half of 2rem */
        padding: 10px 20px; /* Half padding */
      }
      #pauseText {
        font-size: 0.75vh; /* Half of 1.5vh */
      }
      #waveOverlay {
        font-size: 2.5vh; /* Half of 5vh */
      }
      /* Hide custom cursor on mobile */
      #customCursor {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Custom Cursor for Desktop -->
  <div id="customCursor">ü©∑</div>
  
  <!-- Heart cursor for mobile devices -->
  <img id="heartCursor" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg'><text y='50%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='100%'>ü©∑</text></svg>" alt="Heart Cursor">
  
  <!-- Game Statistics and Controls -->
  <div id="gameStats">
    <div id="title">spread love</div>
    <div id="stats" style="line-height: 1.5em;">
      score: 0<br>
      lives left: 3<br>
      wave: 1
    </div>
    <div id="controls">
      <!-- Removed pause and reset buttons as per request -->
    </div>
  </div>
  
  <!-- Start and Restart Buttons -->
  <div id="startButton" onclick="startGame()">start game</div>
  <div id="gameOver">game over</div>
  <div id="restartButton" onclick="restartGame()" style="margin-top: 20px;">restart</div>
  
  <!-- Wave Overlay -->
  <div id="waveOverlay">wave 1!</div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const heartCursor = document.getElementById('heartCursor');
    const waveOverlay = document.getElementById('waveOverlay');
    const customCursor = document.getElementById('customCursor');
    const startButton = document.getElementById('startButton');
    const gameOverText = document.getElementById('gameOver');
    const restartButton = document.getElementById('restartButton');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    let faceSize;
    let cursorCollisionRadius;
    let touchCollisionRadius;
    let score = 0;
    let missed = 0;
    const maxMissed = 3;
    let entities = [];
    let lastTime = Date.now();
    let gameOver = false;
    let isTouching = false;
    let touchX = undefined;
    let touchY = undefined;

    let waveNumber = 1;
    let speedMultiplier = 0.8; // Start a bit slower
    let waveSpawnInterval = 1000;
    let lastWaveSpawnTime = Date.now();
    let isPaused = false;
    let animationFrameId;

    function resizeGame() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      faceSize = Math.min(width, height) / 10; // Base size
      faceSize = Math.max(Math.min(faceSize, 90), 30); // Adjusted max size to 90 to accommodate increased faceSize

      heartCursor.style.width = faceSize * 2 + 'px';
      heartCursor.style.height = faceSize * 2 + 'px';
      heartCursor.style.marginLeft = -faceSize + 'px';
      heartCursor.style.marginTop = -faceSize + 'px';

      cursorCollisionRadius = faceSize; // For desktop cursor

      // Update custom cursor size
      customCursor.style.width = faceSize + 'px';
      customCursor.style.height = faceSize + 'px';
      customCursor.style.fontSize = faceSize + 'px';

      // Define touch collision radius for mobile (10x size big heart)
      touchCollisionRadius = faceSize * 5; // Since big heart is 10x, radius is 5x
    }
    resizeGame();

    function isMobileDevice() {
      return typeof window.orientation !== 'undefined' || navigator.userAgent.indexOf('IEMobile') !== -1;
    }

    if (isMobileDevice()) {
      heartCursor.style.display = 'none'; // Hide heartCursor on mobile to prevent tiny heart
    } else {
      customCursor.style.display = 'block';
    }

    class Entity {
      constructor(x, y, vx, vy, isSad) {
        this.size = faceSize;
        this.x = x;
        this.y = y;
        this.vx = vx * speedMultiplier;
        this.vy = vy * speedMultiplier;
        this.isSad = isSad;
        this.hit = false;
      }

      update(delta) {
        if (this.isSad) {
          // Touch avoidance logic
          if (typeof touchX !== 'undefined' && typeof touchY !== 'undefined') {
            let dx = this.x - touchX;
            let dy = this.y - touchY;
            let distance = Math.hypot(dx, dy);
            let detectionRadius = isMobileDevice() ? touchCollisionRadius : cursorCollisionRadius;

            if (distance < detectionRadius) {
              let nx = dx / distance;
              let ny = dy / distance;
              let avoidSpeed = ((detectionRadius - distance) / detectionRadius) * 2 * speedMultiplier;
              this.vx += nx * avoidSpeed * delta;
              this.vy += ny * avoidSpeed * delta;
            }
          }

          // Add gravity
          const gravity = 0.2 * speedMultiplier;
          this.vy += gravity * delta;

          // Increase erraticness
          this.vx += (Math.random() - 0.5) * 1.2 * delta * speedMultiplier; // Further increased randomness
          this.vy += (Math.random() - 0.5) * 0.8 * delta * speedMultiplier; // Further increased randomness

          // Increase max speed
          let maxSpeed = 10 * speedMultiplier; // Increased max speed to accommodate higher randomness
          let speed = Math.hypot(this.vx, this.vy);
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }

          // Update position
          this.x += this.vx * delta;
          this.y += this.vy * delta;

          // Prevent faces from staying at the top
          if (this.y < this.size / 2 + 10) {
            this.vy = Math.abs(this.vy) + 1 * speedMultiplier;
            this.y = this.size / 2 + 10;
          }

          // Boundary checks
          if (this.x < this.size / 2) {
            this.x = this.size / 2;
            this.vx = -this.vx;
          } else if (this.x > width - this.size / 2) {
            this.x = width - this.size / 2;
            this.vx = -this.vx;
          }

          if (this.y > height + this.size) {
            missed++;
            this.hit = true;
          }
        }

        getFace() {
          if (!this.isSad) {
            return 'üòç';
          } else {
            const progress = this.y / height;
            if (progress < 0.25) {
              return 'üòê';
            } else if (progress < 0.5) {
              return 'üôÅ';
            } else if (progress < 0.75) {
              return 'üò¢';
            } else {
              return 'üò±';
            }
          }
        }

        draw() {
          ctx.font = `${this.size}px "Press Start 2P", cursive`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = 'magenta';
          ctx.fillText(this.getFace(), this.x, this.y);
        }
      }

      function showWaveOverlay(waveNumber) {
        waveOverlay.textContent = `wave ${waveNumber}!`;
        waveOverlay.style.opacity = '1';
        setTimeout(() => {
          waveOverlay.style.opacity = '0';
        }, 2000);
      }

      function spawnEntity() {
        const size = faceSize;
        const x = Math.random() * (width - size) + size / 2;
        const y = -size;
        const vx = (Math.random() - 0.5) * 2.5 * speedMultiplier; // Increased horizontal velocity range
        const vy = (Math.random() * 3.0 + 4.0) * speedMultiplier; // Further increased vy
        entities.push(new Entity(x, y, vx, vy, true));
      }

      function handleTouchStart(e) {
        isTouching = true;
        const touch = e.touches[0];
        touchX = touch.clientX;
        touchY = touch.clientY;

        // Show a large heart at the tap location
        showBigHeart(touchX, touchY);

        // No need to show heartCursor on mobile
        // heartCursor.style.display is already hidden on mobile

        // Adjust collision radius based on device
        const collisionRadius = isMobileDevice() ? touchCollisionRadius : cursorCollisionRadius;

        entities.forEach(entity => {
          const dx = entity.x - touchX;
          const dy = entity.y - touchY;
          const distance = Math.hypot(dx, dy);
          if (entity.isSad && !entity.hit && distance <= entity.size / 2 + collisionRadius) {
            entity.isSad = false;
            entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
            entity.vy = -(Math.random() * 5 + 5) * speedMultiplier;
            score++;
            updateGameStats();

            // Trigger cursor animation (only on desktop)
            animateCursor();

            // Check if it's time to increase the wave
            if (score % 10 === 0) {
              waveNumber++;
              speedMultiplier += 0.1;
              waveSpawnInterval = Math.max(200, waveSpawnInterval - 50);
              updateGameStats();
              showWaveOverlay(waveNumber);
            }
          }
        });
      }

      function handleTouchMove(e) {
        const touch = e.touches[0];
        touchX = touch.clientX;
        touchY = touch.clientY;
      }

      function handleTouchEnd(e) {
        isTouching = false;
        touchX = undefined;
        touchY = undefined;
      }

      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);

      canvas.addEventListener('mousedown', function(e) {
        if (isMobileDevice()) return; // Ignore mouse events on mobile

        // Trigger cursor animation
        animateCursor();

        touchX = e.clientX;
        touchY = e.clientY;

        entities.forEach(entity => {
          const dx = entity.x - touchX;
          const dy = entity.y - touchY;
          const distance = Math.hypot(dx, dy);
          if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
            entity.isSad = false;
            entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
            entity.vy = -(Math.random() * 5 + 5) * speedMultiplier; // Corrected 'this.vy' to 'entity.vy'
            score++;
            updateGameStats();

            // Trigger cursor animation
            animateCursor();

            // Check if it's time to increase the wave
            if (score % 10 === 0) {
              waveNumber++;
              speedMultiplier += 0.1;
              waveSpawnInterval = Math.max(200, waveSpawnInterval - 50);
              updateGameStats();
              showWaveOverlay(waveNumber);
            }
          }
        });
      });

      canvas.addEventListener('mousemove', function(e) {
        if (isTouching) return;
        customCursor.style.left = e.clientX + 'px';
        customCursor.style.top = e.clientY + 'px';
      });

      canvas.addEventListener('mouseleave', function() {
        customCursor.style.opacity = '0';
      });

      canvas.addEventListener('mouseenter', function() {
        customCursor.style.opacity = '1';
      });

      function animateCursor() {
        if (isMobileDevice()) return; // Only animate custom cursor on desktop

        // Add 'active' class to scale up and change to sparkly heart
        customCursor.classList.add('active');
        customCursor.textContent = 'üíñ';

        // After animation duration, revert to normal
        setTimeout(() => {
          customCursor.classList.remove('active');
          customCursor.textContent = 'ü©∑';
        }, 200); // Match the CSS transition duration
      }

      function showBigHeart(x, y) {
        // Create a new div element for the big heart
        const bigHeart = document.createElement('div');
        bigHeart.classList.add('big-heart');
        bigHeart.textContent = 'ü©∑';
        bigHeart.style.left = x + 'px';
        bigHeart.style.top = y + 'px';
        bigHeart.style.fontSize = (faceSize * 10) + 'px'; // Set font size to 10x faceSize
        document.body.appendChild(bigHeart);

        // Trigger the animation
        // Slight delay to ensure the element is rendered before adding the 'animate' class
        setTimeout(() => {
          bigHeart.classList.add('animate');
        }, 10); // 10ms delay

        // Remove the element after the animation completes (0.5s)
        setTimeout(() => {
          bigHeart.remove();
        }, 510); // 500ms for animation + 10ms buffer
      }

      function update() {
        if (gameOver || isPaused) return;

        const now = Date.now();
        const delta = (now - lastTime) / 16;

        ctx.clearRect(0, 0, width, height);

        if (now - lastWaveSpawnTime > waveSpawnInterval) {
          spawnEntity();
          lastWaveSpawnTime = now;
        }

        entities.forEach(entity => {
          entity.update(delta);
          entity.draw();
        });

        entities = entities.filter(entity => !entity.hit);

        if (missed >= maxMissed) {
          endGame();
        }

        lastTime = now;
        animationFrameId = requestAnimationFrame(update);
      }

      function updateGameStats() {
        document.getElementById('stats').innerHTML = `
          score: ${score}<br>
          lives left: ${maxMissed - missed}<br>
          wave: ${waveNumber}
        `;
      }

      function endGame() {
        gameOver = true;
        cancelAnimationFrame(animationFrameId);
        gameOverText.style.display = 'block';
        restartButton.style.display = 'block';
      }

      function startGame() {
        startButton.style.display = 'none';
        lastTime = Date.now(); // Reset lastTime
        lastWaveSpawnTime = Date.now(); // Reset lastWaveSpawnTime
        gameOver = false;
        score = 0;
        missed = 0;
        waveNumber = 1;
        speedMultiplier = 0.8;
        waveSpawnInterval = 1000;
        entities = [];
        updateGameStats();
        showWaveOverlay(waveNumber);
        update();
      }

      function restartGame() {
        gameOverText.style.display = 'none';
        restartButton.style.display = 'none';
        startGame();
      }

      // Ensure the game resizes properly when the window size changes
      window.addEventListener('resize', () => {
        resizeGame();
      });

      // Initialize the game stats
      updateGameStats();

      // Show the start button when the page loads
      startButton.style.display = 'block';
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Viewport meta tag for responsive design -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart Catch Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      overflow: hidden;
      touch-action: none;
      cursor: none; /* Hide the default cursor */
      position: relative;
      height: 100vh;
      width: 100vw;
      transition: background-color 0.5s;

      /* Grid Background */
      background-color: #ffffff;
      background-image:
        linear-gradient(rgba(211, 211, 211, 0.5) 1px, transparent 1px),
        linear-gradient(90deg, rgba(211, 211, 211, 0.5) 1px, transparent 1px);
      background-size: 100px 100px;
      background-position: 0px 0px;
      background-repeat: repeat;
    }
    body.nightmode {
      background-color: #000000;
      background-image:
        linear-gradient(rgba(100, 100, 100, 0.5) 1px, transparent 1px),
        linear-gradient(90deg, rgba(100, 100, 100, 0.5) 1px, transparent 1px);
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5; /* Positioned below gameStats */
    }
    /* Custom Cursor */
    #customCursor {
      position: absolute;
      pointer-events: none;
      z-index: 1000;
      width: 90px; /* Adjusted size */
      height: 90px;
      transform: translate(-50%, -50%) scale(1);
      transition: transform 0.2s ease;
      font-size: 90px;
      line-height: 90px;
      text-align: center;
      user-select: none;
      opacity: 1;
    }
    /* Active state for cursor animation */
    #customCursor.active {
      transform: translate(-50%, -50%) scale(1.75); /* Scale up by 75% (1.75x) */
    }
    /* Big Heart for Mobile Taps */
    .big-heart {
      position: absolute;
      pointer-events: none;
      z-index: 1001; /* Above the custom cursor */
      font-size: 600%; /* Approximately 6x scaling based on faceSize */
      opacity: 1;
      transition: opacity 0.5s, transform 0.5s;
      transform: translate(-50%, -50%) scale(1);
      user-select: none;
    }
    .big-heart.animate {
      opacity: 0;
      transform: translate(-50%, -50%) scale(1.5); /* Scale up further during animation */
    }
    #heartCursor {
      position: absolute;
      pointer-events: none;
      display: none;
      z-index: 10;
      width: 90px; /* Adjusted size */
      height: 90px;
      transform: translate(-50%, -50%) scale(1);
      transition: transform 0.2s ease;
      font-size: 90px;
      line-height: 90px;
      text-align: center;
      user-select: none;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 6vh;
      color: magenta;
      display: none;
      z-index: 15;
      margin-bottom: 2vh; /* Adds space between game over and restart */
      pointer-events: none;
    }
    #startButton, #restartButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: transparent;
      color: magenta;
      padding: 20px 40px;
      border: 3px solid magenta;
      border-radius: 5px;
      cursor: pointer; /* Show pointer cursor for buttons */
      font-family: 'Press Start 2P', cursive;
      font-size: 2rem;
      display: none;
      user-select: none;
      z-index: 15;
    }
    #startButton:hover, #restartButton:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    #gameStats {
      position: absolute;
      top: 5%;
      left: 5%;
      color: magenta;
      z-index: 10; /* Positioned above the canvas */
      text-align: left;
      font-family: 'Press Start 2P', cursive;
      pointer-events: none; /* Prevents interference with gameplay */
    }
    #title {
      font-size: 4vh;
      word-wrap: break-word; /* Ensure text wraps if too long */
      max-width: 90vw; /* Prevent overflow by limiting width */
    }
    #stats {
      font-size: 2vh;
      margin-top: 1vh; /* Blank line */
    }
    #waveOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: magenta;
      font-size: 5vh;
      opacity: 0;
      transition: opacity 1s;
      z-index: 20;
      pointer-events: none;
    }
    /* Menu Icon */
    #menuIcon {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 30px;
      height: 25px;
      cursor: pointer;
      z-index: 15;
    }
    /* Hamburger Icon Lines */
    #menuIcon div {
      width: 100%;
      height: 4px;
      background-color: magenta;
      margin: 5px 0;
    }
    /* Menu Overlay */
    #menuOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      display: none;
      z-index: 20;
      overflow: auto;
      cursor: default; /* Ensure cursor is visible in menu */
    }
    body.nightmode #menuOverlay {
      background-color: black;
    }
    /* Close Button */
    #menuCloseButton {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 30px;
      height: 25px;
      cursor: pointer;
    }
    /* X Icon Lines */
    #menuCloseButton:before, #menuCloseButton:after {
      content: '';
      position: absolute;
      width: 100%;
      height: 4px;
      background-color: magenta;
      top: 10px;
      left: 0;
    }
    #menuCloseButton:before {
      transform: rotate(45deg);
    }
    #menuCloseButton:after {
      transform: rotate(-45deg);
    }
    /* Menu Content */
    #menuContent {
      margin-top: 80px;
      text-align: center;
      color: magenta;
      font-family: 'Press Start 2P', cursive;
    }
    #menuContent h1 {
      font-size: 3rem;
      margin-bottom: 40px;
    }
    .menu-option {
      margin: 20px auto;
      max-width: 300px;
    }
    .menu-option label {
      display: block;
      font-size: 1.5rem;
      margin-bottom: 10px;
    }
    .menu-option input[type="range"] {
      width: 100%; /* Adjusted to be narrower */
    }
    .menu-option input[type="number"] {
      width: 80px;
      font-size: 1.5rem;
      text-align: center;
    }
    .menu-option input[type="checkbox"] {
      transform: scale(1.5);
      margin-top: 10px;
    }
    /* Wave Selector */
    #waveSelector {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .wave-button {
      font-size: 2rem;
      cursor: pointer;
      user-select: none;
      margin: 0 10px;
    }
    #waveNumber {
      font-size: 1.5rem;
      width: 50px;
      text-align: center;
    }
    /* Media Query for Mobile Devices */
    @media only screen and (max-width: 768px) {
      #title {
        font-size: 2vh; /* Half of 4vh */
        max-width: 90vw; /* Ensure it doesn't exceed viewport */
      }
      #stats {
        font-size: 1vh; /* Half of 2vh */
      }
      #gameOver {
        font-size: 3vh; /* Half of 6vh */
      }
      #startButton, #restartButton {
        font-size: 1rem; /* Half of 2rem */
        padding: 10px 20px; /* Half padding */
      }
      #waveOverlay {
        font-size: 2.5vh; /* Half of 5vh */
      }
      /* Show custom cursor on mobile */
      #customCursor {
        display: block;
      }
      /* Hide heartCursor on mobile to remove tiny heart */
      #heartCursor {
        display: none;
      }
      /* Adjust menu icon size */
      #menuIcon, #menuCloseButton {
        top: 10px;
        right: 10px;
        width: 25px;
        height: 20px;
      }
      #menuIcon div, #menuCloseButton:before, #menuCloseButton:after {
        height: 3px;
      }
      /* Adjust menu content */
      #menuContent h1 {
        font-size: 2rem;
      }
      .menu-option label {
        font-size: 1.2rem;
      }
      .menu-option input[type="number"] {
        width: 60px;
        font-size: 1.2rem;
      }
      .menu-option input[type="range"] {
        width: 100%;
      }
      .wave-button {
        font-size: 1.5rem;
      }
      #waveNumber {
        font-size: 1rem;
        width: 40px;
      }
    }
  </style>
</head>
<body>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- Custom Cursor for Desktop and Mobile -->
  <div id="customCursor">ðŸ©·</div>

  <!-- Heart cursor for mobile devices -->
  <img id="heartCursor" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg'><text y='50%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='100%'>ðŸ©·</text></svg>" alt="Heart Cursor">

  <!-- Game Statistics and Controls -->
  <div id="gameStats">
    <div id="title">spread love</div>
    <div id="stats" style="line-height: 1.5em;">
      score: 0<br>
      lives left: 3<br>
      wave: 1
    </div>
  </div>

  <!-- Start and Restart Buttons -->
  <div id="startButton" onclick="startGame()">start game</div>
  <div id="gameOver">game over</div>
  <div id="restartButton" onclick="restartGame()" style="margin-top: 20px;">restart</div>

  <!-- Wave Overlay -->
  <div id="waveOverlay">wave 1!</div>

  <!-- Menu Icon -->
  <div id="menuIcon" onclick="openMenu()">
    <div></div>
    <div></div>
    <div></div>
  </div>

  <!-- Menu Overlay -->
  <div id="menuOverlay">
    <div id="menuCloseButton" onclick="closeMenu()"></div>
    <div id="menuContent">
      <h1>options</h1>
      <!-- Menu Options -->
      <div class="menu-option">
        <label>wave</label>
        <div id="waveSelector">
          <span id="decreaseWave" class="wave-button">[</span>
          <span id="waveNumber">1</span>
          <span id="increaseWave" class="wave-button">]</span>
        </div>
      </div>
      <div class="menu-option">
        <label for="emojiSize">emoji size</label>
        <input type="range" id="emojiSize" min="50" max="150" value="100">
      </div>
      <div class="menu-option">
        <label for="tracers">tracers</label>
        <input type="checkbox" id="tracers">
      </div>
      <div class="menu-option">
        <label for="soundToggle">sound</label>
        <input type="checkbox" id="soundToggle" checked>
      </div>
      <div class="menu-option">
        <label for="volumeSlider">volume</label>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
      </div>
      <div class="menu-option">
        <label for="nightModeToggle">night mode</label>
        <input type="checkbox" id="nightModeToggle">
      </div>
      <div class="menu-option">
        <label for="clickModeToggle">click/tap mode</label>
        <input type="checkbox" id="clickModeToggle" checked>
      </div>
    </div>
  </div>

  <!-- Audio Elements -->
  <!-- Removed the bonkSound element to handle audio differently -->

  <script>
    // Constants for base sizes
    const baseFaceSizeDesktop = 90; // Adjusted size for desktop
    const baseFaceSizeMobile = 60;   // Original size for mobile

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const heartCursor = document.getElementById('heartCursor');
    const waveOverlay = document.getElementById('waveOverlay');
    const customCursor = document.getElementById('customCursor');
    const startButton = document.getElementById('startButton');
    const gameOverText = document.getElementById('gameOver');
    const restartButton = document.getElementById('restartButton');
    const menuIcon = document.getElementById('menuIcon');
    const menuOverlay = document.getElementById('menuOverlay');
    const menuCloseButton = document.getElementById('menuCloseButton');
    const emojiSizeInput = document.getElementById('emojiSize');
    const tracersCheckbox = document.getElementById('tracers');
    const soundToggle = document.getElementById('soundToggle');
    const volumeSlider = document.getElementById('volumeSlider');
    const nightModeToggle = document.getElementById('nightModeToggle');
    const clickModeToggle = document.getElementById('clickModeToggle');

    // Wave selector elements
    const decreaseWaveButton = document.getElementById('decreaseWave');
    const increaseWaveButton = document.getElementById('increaseWave');
    const waveNumberDisplay = document.getElementById('waveNumber');

    let selectedWaveNumber = 1; // Initialize selected wave number

    decreaseWaveButton.addEventListener('click', () => {
      if (selectedWaveNumber > 1) {
        selectedWaveNumber--;
        waveNumberDisplay.textContent = selectedWaveNumber;
      }
    });

    increaseWaveButton.addEventListener('click', () => {
      if (selectedWaveNumber < 20) {
        selectedWaveNumber++;
        waveNumberDisplay.textContent = selectedWaveNumber;
      }
    });

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    let faceSize;
    let cursorCollisionRadius;
    let score = 0;
    let missed = 0;
    const maxMissed = 3;
    let entities = [];
    let lastTime = Date.now();
    let gameOver = false;
    let isTouching = false;
    let touchX = undefined;
    let touchY = undefined;

    let waveNumber = 1;
    let speedMultiplier = 0.8; // Start slower
    let waveSpawnInterval = 1000; // Spawn less frequently
    let lastWaveSpawnTime = Date.now();
    let isPaused = false;
    let animationFrameId;
    let gameStarted = false; // Flag to check if the game has started
    let clickModeEnabled = true; // Click mode enabled by default

    // Evasion parameters
    const baseEvasionRadius = 200; // Base evasion radius
    const maxEvasionForce = 1; // Maximum steering force

    // Grid Animation Variables
    let gridOffsetY = 0;
    const gridSize = 100; // Must match background-size in CSS
    const gridScrollFactor = 1; // Adjust this to match emoji speed

    // Tracer Variables
    let tracerEnabled = tracersCheckbox.checked;
    let tracerPath = [];

    // Sound Variables
    let soundEnabled = soundToggle.checked;
    let volumeLevel = parseFloat(volumeSlider.value);
    const bonkSounds = [];
    let bonkSoundIndex = 0;

    function resizeGame() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      let sliderValue = parseInt(emojiSizeInput.value); // Use the value from the slider

      // Calculate faceSize based on device and slider value
      if (isMobileDevice()) {
        faceSize = (sliderValue / 100) * baseFaceSizeMobile;
      } else {
        faceSize = (sliderValue / 100) * baseFaceSizeDesktop;
      }

      // Update cursor sizes
      heartCursor.style.width = faceSize * 2 + 'px';
      heartCursor.style.height = faceSize * 2 + 'px';
      heartCursor.style.marginLeft = -faceSize + 'px';
      heartCursor.style.marginTop = -faceSize + 'px';

      if (isMobileDevice()) {
        // On mobile devices, make the custom cursor 2x larger
        customCursor.style.width = faceSize * 2 + 'px';
        customCursor.style.height = faceSize * 2 + 'px';
        customCursor.style.fontSize = faceSize * 2 + 'px';
        customCursor.style.lineHeight = faceSize * 2 + 'px';
        cursorCollisionRadius = faceSize * 2;
      } else {
        customCursor.style.width = faceSize + 'px';
        customCursor.style.height = faceSize + 'px';
        customCursor.style.fontSize = faceSize + 'px';
        customCursor.style.lineHeight = faceSize + 'px';
        cursorCollisionRadius = faceSize;
      }

      // Update sizes of existing entities
      entities.forEach(entity => {
        entity.size = faceSize;
      });
    }

    function isMobileDevice() {
      return typeof window.orientation !== 'undefined' || navigator.userAgent.indexOf('IEMobile') !== -1;
    }

    // Show custom cursor on both desktop and mobile
    customCursor.style.display = 'block';

    // Set initial emoji size based on device
    if (isMobileDevice()) {
      emojiSizeInput.value = emojiSizeInput.min;
    } else {
      emojiSizeInput.value = '100'; // default value
    }

    resizeGame();

    class Entity {
      constructor(x, y, vx, vy, isSad) {
        this.size = faceSize;
        this.x = x;
        this.y = y;
        this.isSad = isSad;
        this.hit = false;
        this.time = 0;

        this.baseVy = vy * speedMultiplier;

        // Movement variations
        this.movementTypes = getRandomMovementTypes();
        this.currentMovementIndex = 0;
        this.movementDuration = Math.random() * 100 + 50; // Duration for each movement type
        this.movementTime = 0;

        // Adjusted amplitude to allow for larger movements
        this.amplitude = Math.random() < 0.5 ? (Math.random() * 20 + 10) : (Math.random() * 10 + 5);
        this.frequency = Math.random() * 0.1 + 0.02; // Adjusted frequency for larger movements

        // Adjust frequency for loop movement to ensure at least two full loops
        if (this.movementTypes[this.currentMovementIndex] === 'loop' || this.movementTypes[this.currentMovementIndex] === 'circle') {
          const totalVerticalDistance = height + this.size * 2; // From y = -size to y = height + size
          const averageVy = Math.abs(this.baseVy) + this.amplitude * speedMultiplier; // Approximate average vertical speed
          const totalTimeOnScreen = totalVerticalDistance / averageVy;
          const numberOfLoops = Math.random() < 0.5 ? 1 : 2; // Randomly 1 or 2 loops
          this.frequency = (2 * numberOfLoops * Math.PI) / totalTimeOnScreen;
        }

        // Variable speed
        this.hasAcceleration = Math.random() < 0.5; // 50% chance
        if (this.hasAcceleration) {
          this.vx = vx * speedMultiplier;
          this.vy = (vy * speedMultiplier) * 0.5; // Start at half speed
          this.acceleration = (Math.random() * 0.1 + 0.05) * speedMultiplier; // Acceleration between 0.05 and 0.15
        } else {
          this.vx = vx * speedMultiplier;
          this.vy = vy * speedMultiplier;
          this.acceleration = 0;
        }

        if (this.movementTypes[this.currentMovementIndex] === 'diagonal') {
          this.diagonalDirection = Math.random() < 0.5 ? -1 : 1;
        }

        // Tracer for this entity
        this.tracerPath = [];
        this.hasPaused = false; // To ensure straight emojis pause once
      }

      update(delta) {
        this.time += delta;
        this.movementTime += delta;

        if (this.movementTime > this.movementDuration) {
          // Switch to next movement type
          this.currentMovementIndex = (this.currentMovementIndex + 1) % this.movementTypes.length;
          this.movementTime = 0;

          // Randomize new duration, amplitude, and frequency
          this.movementDuration = Math.random() * 100 + 50;
          this.amplitude = Math.random() < 0.5 ? (Math.random() * 20 + 10) : (Math.random() * 10 + 5);

          if (this.movementTypes[this.currentMovementIndex] === 'loop' || this.movementTypes[this.currentMovementIndex] === 'circle') {
            const totalVerticalDistance = height + this.size * 2; // From y = -size to y = height + size
            const averageVy = Math.abs(this.baseVy) + this.amplitude * speedMultiplier; // Approximate average vertical speed
            const totalTimeOnScreen = totalVerticalDistance / averageVy;
            const numberOfLoops = Math.random() < 0.5 ? 1 : 2; // Randomly 1 or 2 loops
            this.frequency = (2 * numberOfLoops * Math.PI) / totalTimeOnScreen;
          } else {
            this.frequency = Math.random() * 0.1 + 0.02;
          }

          if (this.movementTypes[this.currentMovementIndex] === 'diagonal') {
            this.diagonalDirection = Math.random() < 0.5 ? -1 : 1;
          }
        }

        if (this.isSad) {
          // Evasion behavior
          let isEvading = false;
          if (typeof touchX !== 'undefined' && typeof touchY !== 'undefined') {
            const dx = this.x - touchX;
            const dy = this.y - touchY;
            const distance = Math.hypot(dx, dy);

            // Adjust evasion radius based on current wave
            const evasionRadius = baseEvasionRadius; // Evasion radius is constant

            if (distance < evasionRadius) {
              isEvading = true;

              // Calculate desired velocity away from cursor
              const desiredSpeed = this.getMaxSpeed();
              const desiredVx = (dx / distance) * desiredSpeed;
              const desiredVy = (dy / distance) * desiredSpeed;

              // Calculate steering force
              let steerX = desiredVx - this.vx;
              let steerY = desiredVy - this.vy;

              // Limit steering force
              const steerMag = Math.hypot(steerX, steerY);
              const maxForce = maxEvasionForce; // Evasion force is constant
              if (steerMag > maxForce) {
                steerX = (steerX / steerMag) * maxForce;
                steerY = (steerY / steerMag) * maxForce;
              }

              // Apply steering force
              this.vx += steerX * delta;
              this.vy += steerY * delta;
            }
          }

          // Apply movement patterns
          switch(this.movementTypes[this.currentMovementIndex]) {
            case 'zigzag':
              this.vx = Math.sin(this.time * this.frequency) * this.amplitude * speedMultiplier;
              break;
            case 'circle':
              this.vx = Math.cos(this.time * this.frequency) * this.amplitude * speedMultiplier;
              this.vy = Math.sin(this.time * this.frequency) * this.amplitude * speedMultiplier + this.baseVy;
              break;
            case 'diagonal':
              this.vx = this.diagonalDirection * this.amplitude * speedMultiplier;
              break;
            case 'zigzig':
              this.vx = Math.sin(this.time * this.frequency * 2) * this.amplitude * speedMultiplier;
              break;
            case 'loop':
              this.vx = Math.sin(this.time * this.frequency) * this.amplitude * speedMultiplier;
              this.vy = Math.cos(this.time * this.frequency) * this.amplitude * speedMultiplier + this.baseVy;
              break;
            case 'random':
              // Randomly adjust vx and vy
              this.vx += (Math.random() - 0.5) * this.amplitude * delta * speedMultiplier;
              this.vy += (Math.random() - 0.5) * this.amplitude * delta * speedMultiplier;
              break;
            case 'straight':
              this.vx = 0;
              this.vy = this.baseVy;
              // Ensure it pauses within the first half of the screen
              if (!this.hasPaused && this.y >= height / 2) {
                this.currentMovementIndex = (this.currentMovementIndex + 1) % this.movementTypes.length;
                this.movementTime = 0;
                this.hasPaused = true;
              }
              break;
            case 'variableSpeed':
              this.vx = 0;
              this.vy = this.baseVy + Math.sin(this.time * this.frequency) * this.amplitude * speedMultiplier;
              break;
            case 'pause':
              this.vx = 0;
              this.vy = 0;
              break;
          }

          // Apply acceleration
          if (this.hasAcceleration) {
            this.vy += this.acceleration * delta;
          }

          // Add gravity
          const gravity = 0.2 * speedMultiplier;
          this.vy += gravity * delta;

          // Update position
          this.x += this.vx * delta;
          this.y += this.vy * delta;

          // Limit speed
          let speed = Math.hypot(this.vx, this.vy);
          const maxSpeed = this.getMaxSpeed();
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }

          // Prevent faces from staying at the top
          if (this.y < this.size / 2 + 10) {
            this.vy = Math.abs(this.vy) + 1 * speedMultiplier;
            this.y = this.size / 2 + 10;
          }

          // Boundary checks for x
          if (this.x < this.size / 2) {
            this.x = this.size / 2;
            if (this.vx <= 0) this.vx = Math.abs(this.vx) + 1 * speedMultiplier; // Bounce right with minimum speed
          } else if (this.x > width - this.size / 2) {
            this.x = width - this.size / 2;
            if (this.vx >= 0) this.vx = -Math.abs(this.vx) - 1 * speedMultiplier; // Bounce left with minimum speed
          }

          if (this.y > height + this.size) {
            missed++;
            this.hit = true;
          }

          // Update tracer path
          if (tracerEnabled && (!clickModeEnabled || !isMobileDevice())) {
            this.tracerPath.push({ x: this.x, y: this.y, face: this.getFace() });
            if (this.tracerPath.length > 10) {
              this.tracerPath.shift();
            }
          } else {
            this.tracerPath = [];
          }
        } else {
          // Happy faces movement
          // Increase erraticness
          this.vx += (Math.random() - 0.5) * 0.6 * delta * speedMultiplier;
          this.vy += (Math.random() - 0.5) * 0.6 * delta * speedMultiplier;

          // Limit speed
          let speed = Math.hypot(this.vx, this.vy);
          const maxSpeed = 9 * speedMultiplier;
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }

          // Update position
          this.x += this.vx * delta;
          this.y += this.vy * delta;

          // Boundary checks
          if (this.x < this.size / 2) {
            this.x = this.size / 2;
            this.vx = -this.vx;
          } else if (this.x > width - this.size / 2) {
            this.x = width - this.size / 2;
            this.vx = -this.vx;
          }

          if (this.y < -this.size) {
            this.hit = true;
          }

          // Clear tracer path for happy faces
          this.tracerPath = [];
        }
      }

      getFace() {
        if (!this.isSad) {
          return 'ðŸ˜';
        } else {
          const progress = this.y / height;
          if (progress < 0.25) {
            return 'ðŸ˜';
          } else if (progress < 0.5) {
            return 'ðŸ™';
          } else if (progress < 0.75) {
            return 'ðŸ˜¢';
          } else {
            return 'ðŸ˜±';
          }
        }
      }

      getMaxSpeed() {
        return 10; // Evasion speed is constant
      }

      draw() {
        // Draw tracer if enabled
        if (this.tracerPath.length > 0) {
          for (let i = 0; i < this.tracerPath.length; i++) {
            const point = this.tracerPath[i];
            const alpha = (i + 1) / this.tracerPath.length;
            ctx.globalAlpha = alpha * 0.6; // Adjust opacity
            ctx.font = `${this.size}px "Press Start 2P", cursive`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'magenta';
            ctx.fillText(point.face, point.x, point.y);
          }
          ctx.globalAlpha = 1.0; // Reset opacity
        }

        ctx.font = `${this.size}px "Press Start 2P", cursive`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'magenta';
        ctx.fillText(this.getFace(), this.x, this.y);
      }
    }

    function getRandomMovementTypes() {
      const movementTypes = ['zigzag', 'circle', 'diagonal', 'zigzig', 'loop', 'random', 'variableSpeed'];
      const selectedTypes = [];

      const randomNumber = Math.random();

      if (randomNumber < 0.2) { // 20% chance of 'straightThenOther'
        // Start with 'straight', then switch to another movement type
        selectedTypes.push('straight');
        selectedTypes.push('pause');
        const otherType = movementTypes[Math.floor(Math.random() * movementTypes.length)];
        selectedTypes.push(otherType);
      } else if (randomNumber < 0.4) { // 20% chance to have 'straight' with a 'pause'
        selectedTypes.push('straight');
        selectedTypes.push('pause');
        selectedTypes.push('straight');
      } else {
        const numberOfTypes = Math.floor(Math.random() * 3) + 1; // Between 1 and 3 movement types
        for (let i = 0; i < numberOfTypes; i++) {
          const type = movementTypes[Math.floor(Math.random() * movementTypes.length)];
          selectedTypes.push(type);
        }
      }

      return selectedTypes;
    }

    function showWaveOverlay(waveNumber) {
      waveOverlay.textContent = `wave ${waveNumber}!`;
      waveOverlay.style.opacity = '1';
      setTimeout(() => {
        waveOverlay.style.opacity = '0';
      }, 2000);
    }

    function spawnEntity() {
      const size = faceSize;
      const x = Math.random() * (width - size) + size / 2;
      const y = -size;
      const vx = (Math.random() - 0.5) * 2.5 * speedMultiplier; // Increased horizontal velocity range
      const vy = (Math.random() * 3.0 + 4.0) * speedMultiplier; // Further increased vy
      entities.push(new Entity(x, y, vx, vy, true));
    }

    function handleTouchStart(e) {
      isTouching = true;
      const touch = e.touches[0];
      touchX = touch.clientX;
      touchY = touch.clientY;
      customCursor.style.left = touchX + 'px';
      customCursor.style.top = touchY + 'px';
      customCursor.style.opacity = '1';

      if (clickModeEnabled) {
        handleInteraction(touch.clientX, touch.clientY);
        animateCursor();
      }
    }

    function handleTouchMove(e) {
      const touch = e.touches[0];
      touchX = touch.clientX;
      touchY = touch.clientY;
      customCursor.style.left = touchX + 'px';
      customCursor.style.top = touchY + 'px';
      customCursor.style.opacity = '1';
    }

    function handleTouchEnd(e) {
      isTouching = false;
      touchX = undefined;
      touchY = undefined;
      customCursor.style.opacity = '0';
    }

    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);

    canvas.addEventListener('mousedown', function(e) {
      if (isMobileDevice()) return; // Ignore mouse events on mobile
      isTouching = true;
      touchX = e.clientX;
      touchY = e.clientY;
      customCursor.style.left = touchX + 'px';
      customCursor.style.top = touchY + 'px';

      if (clickModeEnabled) {
        handleInteraction(e.clientX, e.clientY);
        animateCursor();
      }
    });

    canvas.addEventListener('mousemove', function(e) {
      touchX = e.clientX;
      touchY = e.clientY;
      customCursor.style.left = touchX + 'px';
      customCursor.style.top = touchY + 'px';
    });

    canvas.addEventListener('mouseup', function(e) {
      isTouching = false;
    });

    canvas.addEventListener('mouseleave', function() {
      customCursor.style.opacity = '0';
      touchX = undefined;
      touchY = undefined;
    });

    canvas.addEventListener('mouseenter', function() {
      customCursor.style.opacity = '1';
    });

    function animateCursor() {
      // Add 'active' class to scale up and change to sparkly heart
      customCursor.classList.add('active');
      customCursor.textContent = 'ðŸ’–';

      // After animation duration, revert to normal
      setTimeout(() => {
        customCursor.classList.remove('active');
        customCursor.textContent = 'ðŸ©·';
      }, 200); // Match the CSS transition duration
    }

    function playBonkSound() {
      if (!soundEnabled) return;

      const bonkSound = bonkSounds[bonkSoundIndex];
      bonkSound.currentTime = 0; // Reset to start
      bonkSound.volume = volumeLevel;
      bonkSound.play();

      bonkSoundIndex = (bonkSoundIndex + 1) % bonkSounds.length;
    }

    function handleInteraction(x, y) {
      const clickScale = 1.75; // Scale factor from CSS
      const clickRadius = cursorCollisionRadius * clickScale;

      entities.forEach(entity => {
        const dx = entity.x - x;
        const dy = entity.y - y;
        const distance = Math.hypot(dx, dy);

        if (entity.isSad && !entity.hit && distance <= entity.size / 2 + clickRadius) {
          entity.isSad = false;
          entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
          entity.vy = -(Math.random() * 5 + 5) * speedMultiplier;
          score++;
          updateGameStats();

          // Play bonk sound
          playBonkSound();

          // Check if it's time to increase the wave
          if (score % 10 === 0) {
            waveNumber++;
            speedMultiplier += 0.1;
            waveSpawnInterval = Math.max(200, 1000 - (waveNumber - 1) * 50);
            updateGameStats();
            showWaveOverlay(waveNumber);
          }
        }
      });
    }

    function update() {
      if (gameOver) return;

      if (isPaused) {
        requestAnimationFrame(update);
        return;
      }

      const now = Date.now();
      const delta = (now - lastTime) / 16;

      // Clear the canvas
      ctx.clearRect(0, 0, width, height);

      // Draw tracer if enabled
      if (tracerEnabled && tracerPath.length > 1 && (!clickModeEnabled || !isMobileDevice())) {
        for (let i = 1; i < tracerPath.length; i++) {
          const start = tracerPath[i - 1];
          const end = tracerPath[i];
          const alpha = (tracerPath.length - i) / tracerPath.length;
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.strokeStyle = `rgba(255, 0, 255, ${alpha})`; // Magenta with varying opacity
          ctx.lineWidth = faceSize / 5; // Wider tracer
          ctx.lineCap = 'round';
          ctx.stroke();
        }
      }

      if (now - lastWaveSpawnTime > waveSpawnInterval) {
        spawnEntity();
        lastWaveSpawnTime = now;
      }

      // Update grid position
      gridOffsetY += speedMultiplier * gridScrollFactor * delta;
      if (gridOffsetY >= gridSize) {
        gridOffsetY = gridOffsetY - gridSize;
      }
      document.body.style.backgroundPosition = `0px ${gridOffsetY}px`;

      entities.forEach(entity => {
        entity.update(delta);
        entity.draw();
      });

      // Collision detection between cursor and entities
      if (typeof touchX !== 'undefined' && typeof touchY !== 'undefined') {
        if (!clickModeEnabled) {
          entities.forEach(entity => {
            const dx = entity.x - touchX;
            const dy = entity.y - touchY;
            const distance = Math.hypot(dx, dy);

            if (entity.isSad && !entity.hit && distance <= entity.size / 2 + cursorCollisionRadius) {
              entity.isSad = false;
              entity.vx = (Math.random() - 0.5) * 4 * speedMultiplier;
              entity.vy = -(Math.random() * 5 + 5) * speedMultiplier;
              score++;
              updateGameStats();

              // Trigger cursor animation
              animateCursor();

              // Play bonk sound
              playBonkSound();

              // Check if it's time to increase the wave
              if (score % 10 === 0) {
                waveNumber++;
                speedMultiplier += 0.1;
                waveSpawnInterval = Math.max(200, 1000 - (waveNumber - 1) * 50);
                updateGameStats();
                showWaveOverlay(waveNumber);
              }
            }
          });
        }

        // Update tracer path
        if (tracerEnabled && (!clickModeEnabled || !isMobileDevice())) {
          tracerPath.push({ x: touchX, y: touchY });
          if (tracerPath.length > 20) {
            tracerPath.shift();
          }
        } else {
          tracerPath = [];
        }
      } else {
        tracerPath = [];
      }

      entities = entities.filter(entity => !entity.hit);

      if (missed >= maxMissed) {
        endGame();
      }

      lastTime = now;
      animationFrameId = requestAnimationFrame(update);
    }

    function updateGameStats() {
      document.getElementById('stats').innerHTML = `
        score: ${score}<br>
        lives left: ${maxMissed - missed}<br>
        wave: ${waveNumber}
      `;
    }

    function endGame() {
      gameOver = true;
      gameStarted = false;
      cancelAnimationFrame(animationFrameId);
      gameOverText.style.display = 'block';
      restartButton.style.display = 'block';
    }

    function startGame() {
      startButton.style.display = 'none';
      gameOverText.style.display = 'none';
      restartButton.style.display = 'none';
      lastTime = Date.now(); // Reset lastTime
      lastWaveSpawnTime = Date.now(); // Reset lastWaveSpawnTime
      gameOver = false;
      score = 0;
      missed = 0;
      waveNumber = selectedWaveNumber; // Use the selected start wave
      speedMultiplier = 0.8 + (waveNumber - 1) * 0.1; // Adjust speed based on starting wave
      waveSpawnInterval = Math.max(200, 1000 - (waveNumber - 1) * 50); // Adjust spawn rate
      entities = [];
      updateGameStats();
      showWaveOverlay(waveNumber);
      isPaused = false;
      gameStarted = true;

      // Initialize audio elements upon user interaction
      if (bonkSounds.length === 0) {
        for (let i = 0; i < 5; i++) {
          const audio = new Audio('bonk.mp3');
          bonkSounds.push(audio);
        }
      }

      // Set initial volume
      bonkSounds.forEach(sound => {
        sound.volume = volumeLevel;
      });

      update();
    }

    function restartGame() {
      startGame();
    }

    function openMenu() {
      isPaused = true;
      menuOverlay.style.display = 'block';
      document.body.style.cursor = 'default'; // Show cursor in menu
    }

    function closeMenu() {
      // Update settings based on menu inputs
      tracerEnabled = tracersCheckbox.checked;
      soundEnabled = soundToggle.checked;
      volumeLevel = parseFloat(volumeSlider.value);
      clickModeEnabled = clickModeToggle.checked;

      // Update volume for all sounds
      bonkSounds.forEach(sound => {
        sound.volume = volumeLevel;
      });

      // Toggle night mode
      if (nightModeToggle.checked) {
        document.body.classList.add('nightmode');
      } else {
        document.body.classList.remove('nightmode');
      }

      resizeGame(); // Adjust sizes based on new settings

      // Reset tracer paths when tracers are toggled
      tracerPath = [];
      entities.forEach(entity => {
        entity.tracerPath = [];
      });

      menuOverlay.style.display = 'none';
      document.body.style.cursor = 'none'; // Hide cursor when returning to game

      lastTime = Date.now(); // Reset lastTime to avoid large delta

      isPaused = false;

      // Ensure custom cursor is visible after closing the menu
      customCursor.style.opacity = '1';

      // Check if wave number has changed
      if (waveNumber !== selectedWaveNumber) {
        gameStarted = false;
        startButton.style.display = 'block';
      } else if (!gameStarted) {
        startGame(); // Start the game if it hasn't started yet
      }
    }

    // Event listeners for volume and night mode
    volumeSlider.addEventListener('input', () => {
      volumeLevel = parseFloat(volumeSlider.value);
      bonkSounds.forEach(sound => {
        sound.volume = volumeLevel;
      });
    });

    nightModeToggle.addEventListener('change', () => {
      if (nightModeToggle.checked) {
        document.body.classList.add('nightmode');
      } else {
        document.body.classList.remove('nightmode');
      }
    });

    // Ensure the game resizes properly when the window size changes
    window.addEventListener('resize', () => {
      resizeGame();
    });

    // Initialize the game stats
    updateGameStats();

    // Show the start button when the page loads
    startButton.style.display = 'block';
  </script>
</body>
</html>

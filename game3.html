<!DOCTYPE html>
<html>
<head>
    <title>Space Haters</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Scoreboard Styles */
        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 3vh;
            user-select: none;
            z-index: 10;
            text-align: left;
        }

        #scoreboard .title {
            font-size: 4vh;
            margin-bottom: 20px;
        }

        #scoreboard .score,
        #scoreboard .level {
            font-size: 3vh;
            margin-bottom: 20px;
        }

        /* Game Over and Restart Button Styles */
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
        }

        #restartButton {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 15px 30px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
            display: none;
        }

        #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Start Button Styles */
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
        }

        #startButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Level Message Styles */
        .levelMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 5vh;
            user-select: none;
            z-index: 15;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        /* Joystick Styles */
        #leftJoystickContainer, #rightJoystickContainer {
            position: absolute;
            bottom: 10%; /* Moved closer to the edge */
            width: 300px;  /* Reduced size */
            height: 300px; /* Reduced size */
            z-index: 20;
            display: none;
            opacity: 0.5;
            touch-action: none;
        }

        #leftJoystickContainer {
            left: 5%; /* Closer to the left edge */
        }

        #rightJoystickContainer {
            right: 5%; /* Closer to the right edge */
        }

        #leftJoystickBase, #rightJoystickBase {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #ccc;
            border-radius: 50%;
            opacity: 0.3;
        }

        #leftJoystickThumb, #rightJoystickThumb {
            position: absolute;
            width: 120px;   /* Adjusted size */
            height: 120px;  /* Adjusted size */
            top: 90px;      /* Adjusted position */
            left: 90px;     /* Adjusted position */
            background-color: #fff;
            border-radius: 50%;
        }

        /* Show Joystick and Adjustments on Mobile Devices */
        @media (hover: none) and (pointer: coarse) {
            #leftJoystickContainer, #rightJoystickContainer {
                display: block;
            }

            /* Adjust the size of the heart ship on mobile */
            .mobile-heart {
                font-size: 150px !important; /* Slightly smaller size */
            }

            /* Adjust Start and Restart Buttons for Mobile */
            #startButton, #restartButton {
                font-size: 1.5rem;
                padding: 10px 20px;
            }

            /* Adjust Scoreboard for Mobile */
            #scoreboard .title {
                font-size: 3vh;
            }

            #scoreboard .score,
            #scoreboard .level {
                font-size: 2vh;
            }

            #gameOver {
                font-size: 4vh;
            }
        }

        /* Menu Icon Styles */
        #menuIcon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 25px;
            cursor: pointer;
            z-index: 25;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .bar {
            width: 100%;
            height: 4px;
            background-color: magenta;
        }

        /* Menu Overlay Styles */
        #menuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 1);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
        }

        #menuOverlay .closeButton {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 3rem;
            cursor: pointer;
        }

        #menuOverlay h1 {
            font-size: 4vh;
            margin-bottom: 40px;
        }

        #menuOverlay .option {
            display: flex;
            align-items: center;
            font-size: 2vh;
            margin-bottom: 20px;
        }

        #menuOverlay .option input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        #menuOverlay .option input[type="range"] {
            margin-left: 10px;
            width: 200px;
            cursor: pointer;
        }

        /* Level Picker Styles */
        #levelPicker {
            display: flex;
            align-items: center;
            font-size: 2vh;
            margin-bottom: 20px;
        }

        #levelPicker span {
            margin-right: 10px;
        }

        #levelPicker button {
            background-color: transparent;
            border: 2px solid magenta;
            color: magenta;
            padding: 5px 10px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            margin: 0 10px;
        }

        #levelPicker button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #levelDisplay {
            width: 30px;
            text-align: center;
        }

        /* New Options Styles */
        #autofireOption, #firingSpeedOption, #nightmodeOption {
            display: flex;
            align-items: center;
            font-size: 2vh;
            margin-bottom: 20px;
        }

        #autofireOption input[type="checkbox"],
        #nightmodeOption input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        #firingSpeedOption label {
            margin-right: 10px;
        }

        #firingSpeedSlider {
            width: 200px;
            cursor: pointer;
        }
    </style>
    <!-- Include the Press Start 2P font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Menu Icon -->
    <div id="menuIcon">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
    </div>

    <!-- Menu Overlay -->
    <div id="menuOverlay">
        <div class="closeButton">&times;</div>
        <h1>Options</h1>
        <!-- Level Picker at the Top -->
        <div id="levelPicker">
            <span>Level Number</span>
            <button id="decreaseLevel">-</button>
            <span id="levelDisplay">1</span>
            <button id="increaseLevel">+</button>
        </div>
        <!-- Autofire Checkbox -->
        <div id="autofireOption" class="option">
            <input type="checkbox" id="autofireCheckbox">
            <label for="autofireCheckbox">Autofire</label>
        </div>
        <!-- Firing Speed Slider -->
        <div id="firingSpeedOption" class="option">
            <label for="firingSpeedSlider">Firing Speed</label>
            <input type="range" id="firingSpeedSlider" min="1" max="20" step="1" value="5">
        </div>
        <!-- Nightmode Checkbox -->
        <div id="nightmodeOption" class="option">
            <input type="checkbox" id="nightmodeCheckbox" checked>
            <label for="nightmodeCheckbox">Nightmode</label>
        </div>
        <!-- Existing Options -->
        <div class="option">
            <input type="checkbox" id="starsCheckbox" checked>
            <label for="starsCheckbox">Stars</label>
        </div>
        <div class="option">
            <input type="checkbox" id="soundCheckbox" checked>
            <label for="soundCheckbox">Sound</label>
        </div>
        <div class="option">
            <label for="volumeSlider">Volume</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
        </div>
    </div>

    <!-- Audio Element for Bonk Sound -->
    <audio id="bonkSound" src="/bonk.mp3" preload="auto"></audio>

    <!-- Scoreboard -->
    <div id="scoreboard">
        <div class="title">space haters</div>
        <div class="score">score: 0</div>
        <div class="level">level: 1</div>
    </div>
    <!-- Game Over and Restart Button -->
    <div id="gameOver">game over</div>
    <div id="restartButton">restart</div>
    <!-- Start Button -->
    <div id="startButton">start game</div>
    <!-- Background Canvas -->
    <canvas id="backgroundCanvas"></canvas>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <!-- Joysticks for Mobile Devices -->
    <div id="leftJoystickContainer">
        <div id="leftJoystickBase"></div>
        <div id="leftJoystickThumb"></div>
    </div>
    <div id="rightJoystickContainer">
        <div id="rightJoystickBase"></div>
        <div id="rightJoystickThumb"></div>
    </div>
    <script>
        // Initialize variables
        var gameStarted = false;
        var gameOver = false;
        var showStars = true; // Controls the visibility of stars
        var soundOn = true;   // Controls whether sound is enabled
        var soundVolume = 1.0; // Controls the volume of sounds
        var isPaused = false; // Controls game pause state
        var levelChanged = false; // Tracks if level was changed during menu
        var autofire = false; // Tracks if autofire is enabled
        var firingSpeed = 5; // Default firing speed (updated from 10 to 5)
        var autofireInterval = null; // Interval ID for autofire

        // Get the canvases and contexts
        var backgroundCanvas = document.getElementById('backgroundCanvas');
        var bgCtx = backgroundCanvas.getContext('2d');

        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        // Resize canvases to fit the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            initStars(); // Reinitialize stars on resize
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Starfield variables
        var stars = [];
        var numStars = 200;

        function initStars() {
            stars = [];
            for (var i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * backgroundCanvas.width,
                    y: Math.random() * backgroundCanvas.height,
                    z: Math.random() * backgroundCanvas.width
                });
            }
        }

        function moveStars() {
            for (var i = 0; i < stars.length; i++) {
                stars[i].z -= 2;
                if (stars[i].z <= 0) {
                    stars[i].x = Math.random() * backgroundCanvas.width;
                    stars[i].y = Math.random() * backgroundCanvas.height;
                    stars[i].z = backgroundCanvas.width;
                }
            }
        }

        function drawStars() {
            if (showStars && nightmode) {
                bgCtx.fillStyle = 'black';
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                bgCtx.fillStyle = 'white';
                for (var i = 0; i < stars.length; i++) {
                    var k = 128.0 / stars[i].z;
                    var x = (stars[i].x - backgroundCanvas.width / 2) * k + backgroundCanvas.width / 2;
                    var y = (stars[i].y - backgroundCanvas.height / 2) * k + backgroundCanvas.height / 2;
                    if (x >= 0 && x <= backgroundCanvas.width && y >= 0 && y <= backgroundCanvas.height) {
                        var size = (1 - stars[i].z / backgroundCanvas.width) * 2;
                        bgCtx.fillRect(x, y, size, size);
                    }
                }
            } else {
                bgCtx.fillStyle = nightmode ? 'black' : 'white';
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            }
        }

        var backgroundLoopRequest;

        function animateBackground() {
            if (!isPaused) {
                if (showStars && nightmode) {
                    moveStars();
                }
                drawStars();
            }
            backgroundLoopRequest = requestAnimationFrame(animateBackground);
        }

        var nightmode = true; // Default nightmode

        initStars();
        animateBackground();

        // Game variables
        var player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: -Math.PI / 2, // Right side up initially
            shootAngle: 0,
            speed: 0,
            rotation: 0,
            score: 0,
            level: 1,
            fireRate: 1000 / firingSpeed, // Initialized based on firingSpeed slider
            lastShotTime: 0,
            projectileSize: 60, // Increased size
            size: 100, // Increased player size
            firepower: 1 // Number of heart gun power-ups
        };

        var initialPlayerState = JSON.parse(JSON.stringify(player)); // For resetting weapon

        var projectiles = [];
        var enemies = [];
        var keys = {};
        var mouse = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            leftDown: false
        };

        var leftJoystick = {
            active: false,
            identifier: null,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0
        };

        var rightJoystick = {
            active: false,
            identifier: null,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0
        };

        var lastTime = 0;
        var enemySpawnRate = 2000; // milliseconds between spawns
        var lastEnemySpawnTime = 0;
        var enemySizeMultiplier = 1; // Enemies get larger each level

        var largeAsteroidsDestroyed = 0; // Counter for large asteroids destroyed

        var gameLoopRequest;

        // Event listeners for controls
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', function(e) {
            keys[e.code] = false;
        });

        // Mouse controls
        canvas.addEventListener('mousemove', function(e) {
            var rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;

            // Update shooting angle
            var dx = mouse.x - player.x;
            var dy = mouse.y - player.y;
            player.shootAngle = Math.atan2(dy, dx);
        });

        canvas.addEventListener('mousedown', function(e) {
            e.preventDefault();
            if (e.button === 0) {
                mouse.leftDown = true;
                shoot(); // Immediate shoot on mouse down
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            e.preventDefault();
            if (e.button === 0) {
                mouse.leftDown = false;
            }
        });

        // Joystick controls
        var leftJoystickContainer = document.getElementById('leftJoystickContainer');
        var leftJoystickThumb = document.getElementById('leftJoystickThumb');

        var rightJoystickContainer = document.getElementById('rightJoystickContainer');
        var rightJoystickThumb = document.getElementById('rightJoystickThumb');

        // Left joystick event listeners
        leftJoystickContainer.addEventListener('touchstart', function(e) {
            e.preventDefault();
            var touch = e.targetTouches[0];
            leftJoystick.active = true;
            leftJoystick.identifier = touch.identifier;
            leftJoystick.startX = touch.pageX;
            leftJoystick.startY = touch.pageY;
            leftJoystick.x = 0;
            leftJoystick.y = 0;
        });

        leftJoystickContainer.addEventListener('touchmove', function(e) {
            e.preventDefault();
            for (var i = 0; i < e.changedTouches.length; i++) {
                var touch = e.changedTouches[i];
                if (touch.identifier === leftJoystick.identifier) {
                    leftJoystick.x = touch.pageX - leftJoystick.startX;
                    leftJoystick.y = touch.pageY - leftJoystick.startY;

                    // Limit joystick movement and add resistance
                    var maxDistance = 100; // Adjusted based on new joystick size
                    var distance = Math.sqrt(leftJoystick.x * leftJoystick.x + leftJoystick.y * leftJoystick.y);
                    if (distance > maxDistance) {
                        var angle = Math.atan2(leftJoystick.y, leftJoystick.x);
                        leftJoystick.x = Math.cos(angle) * maxDistance;
                        leftJoystick.y = Math.sin(angle) * maxDistance;
                    }

                    leftJoystickThumb.style.transform = 'translate(' + leftJoystick.x + 'px, ' + leftJoystick.y + 'px)';
                    break;
                }
            }
        });

        leftJoystickContainer.addEventListener('touchend', function(e) {
            e.preventDefault();
            for (var i = 0; i < e.changedTouches.length; i++) {
                var touch = e.changedTouches[i];
                if (touch.identifier === leftJoystick.identifier) {
                    leftJoystick.active = false;
                    leftJoystick.identifier = null;
                    leftJoystick.x = 0;
                    leftJoystick.y = 0;
                    leftJoystickThumb.style.transform = 'translate(0, 0)';
                    break;
                }
            }
        });

        leftJoystickContainer.addEventListener('touchcancel', function(e) {
            e.preventDefault();
            leftJoystick.active = false;
            leftJoystick.identifier = null;
            leftJoystick.x = 0;
            leftJoystick.y = 0;
            leftJoystickThumb.style.transform = 'translate(0, 0)';
        });

        // Right joystick event listeners
        rightJoystickContainer.addEventListener('touchstart', function(e) {
            e.preventDefault();
            var touch = e.targetTouches[0];
            rightJoystick.active = true;
            rightJoystick.identifier = touch.identifier;
            rightJoystick.startX = touch.pageX;
            rightJoystick.startY = touch.pageY;
            rightJoystick.x = 0;
            rightJoystick.y = 0;
        });

        rightJoystickContainer.addEventListener('touchmove', function(e) {
            e.preventDefault();
            for (var i = 0; i < e.changedTouches.length; i++) {
                var touch = e.changedTouches[i];
                if (touch.identifier === rightJoystick.identifier) {
                    rightJoystick.x = touch.pageX - rightJoystick.startX;
                    rightJoystick.y = touch.pageY - rightJoystick.startY;

                    // Limit joystick movement
                    var maxDistance = 100;
                    var distance = Math.sqrt(rightJoystick.x * rightJoystick.x + rightJoystick.y * rightJoystick.y);
                    if (distance > maxDistance) {
                        var angle = Math.atan2(rightJoystick.y, rightJoystick.x);
                        rightJoystick.x = Math.cos(angle) * maxDistance;
                        rightJoystick.y = Math.sin(angle) * maxDistance;
                    }

                    rightJoystickThumb.style.transform = 'translate(' + rightJoystick.x + 'px, ' + rightJoystick.y + 'px)';
                    break;
                }
            }
        });

        rightJoystickContainer.addEventListener('touchend', function(e) {
            e.preventDefault();
            for (var i = 0; i < e.changedTouches.length; i++) {
                var touch = e.changedTouches[i];
                if (touch.identifier === rightJoystick.identifier) {
                    rightJoystick.active = false;
                    rightJoystick.identifier = null;
                    rightJoystick.x = 0;
                    rightJoystick.y = 0;
                    rightJoystickThumb.style.transform = 'translate(0, 0)';
                    break;
                }
            }
        });

        rightJoystickContainer.addEventListener('touchcancel', function(e) {
            e.preventDefault();
            rightJoystick.active = false;
            rightJoystick.identifier = null;
            rightJoystick.x = 0;
            rightJoystick.y = 0;
            rightJoystickThumb.style.transform = 'translate(0, 0)';
        });

        // Start and Restart buttons
        var startButton = document.getElementById('startButton');
        var restartButton = document.getElementById('restartButton');

        startButton.addEventListener('click', function() {
            startGame();
        });

        restartButton.addEventListener('click', function() {
            restartGame();
        });

        // Menu functionality
        var menuIcon = document.getElementById('menuIcon');
        var menuOverlay = document.getElementById('menuOverlay');
        var closeButton = document.querySelector('#menuOverlay .closeButton');
        var starsCheckbox = document.getElementById('starsCheckbox');
        var soundCheckbox = document.getElementById('soundCheckbox');
        var volumeSlider = document.getElementById('volumeSlider');
        var bonkSoundElement = document.getElementById('bonkSound');
        var decreaseLevelButton = document.getElementById('decreaseLevel');
        var increaseLevelButton = document.getElementById('increaseLevel');
        var levelDisplay = document.getElementById('levelDisplay');
        var autofireCheckbox = document.getElementById('autofireCheckbox');
        var firingSpeedSlider = document.getElementById('firingSpeedSlider');
        var nightmodeCheckbox = document.getElementById('nightmodeCheckbox');

        menuIcon.addEventListener('click', function() {
            openMenu();
        });

        closeButton.addEventListener('click', function() {
            closeMenu();
        });

        starsCheckbox.addEventListener('change', function() {
            showStars = starsCheckbox.checked;
        });

        soundCheckbox.addEventListener('change', function() {
            soundOn = soundCheckbox.checked;
        });

        volumeSlider.addEventListener('input', function() {
            soundVolume = parseFloat(volumeSlider.value);
            bonkSoundElement.volume = soundVolume;
        });

        decreaseLevelButton.addEventListener('click', function() {
            if (player.level > 1) {
                player.level--;
                levelChanged = true;
                updateLevelDisplay();
                updateLevelSettings();
                updateUI();
            }
        });

        increaseLevelButton.addEventListener('click', function() {
            if (player.level < 10) { // Assuming max level 10
                player.level++;
                levelChanged = true;
                updateLevelDisplay();
                updateLevelSettings();
                updateUI();
            }
        });

        autofireCheckbox.addEventListener('change', function() {
            autofire = autofireCheckbox.checked;
            if (autofire) {
                startAutofire();
            } else {
                stopAutofire();
            }
        });

        firingSpeedSlider.addEventListener('input', function() {
            firingSpeed = parseInt(firingSpeedSlider.value);
            player.fireRate = 1000 / firingSpeed; // Update fire rate based on slider

            if (autofire) {
                stopAutofire();
                startAutofire();
            }
        });

        nightmodeCheckbox.addEventListener('change', function() {
            nightmode = nightmodeCheckbox.checked;
            if (nightmode) {
                // Restore stars and dark background
                showStars = starsCheckbox.checked;
            }
            drawStars(); // Redraw background based on nightmode
        });

        function openMenu() {
            menuOverlay.style.display = 'flex';
            menuIcon.style.display = 'none';
            pauseGame();
        }

        function closeMenu() {
            menuOverlay.style.display = 'none';
            menuIcon.style.display = 'flex';
            if (levelChanged) {
                levelChanged = false;
                restartGame();
            } else {
                resumeGame();
            }
        }

        // Function to play the bonk sound with minimal latency
        function playBonkSound() {
            if (!soundOn) return;
            var soundClone = bonkSoundElement.cloneNode();
            soundClone.volume = soundVolume;
            soundClone.play();
        }

        // Autofire Functions
        function startAutofire() {
            var intervalTime = 1000 / firingSpeed; // milliseconds between shots
            autofireInterval = setInterval(function() {
                shoot(true); // Pass true to indicate autofire shooting
            }, intervalTime);
        }

        function stopAutofire() {
            if (autofireInterval) {
                clearInterval(autofireInterval);
                autofireInterval = null;
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            if (!gameStarted || gameOver || isPaused) return;

            var deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;

            update(deltaTime);
            render();

            gameLoopRequest = requestAnimationFrame(gameLoop);
        }

        // Update function
        function update(deltaTime) {
            handleInput(deltaTime);
            updateProjectiles(deltaTime);
            updateEnemies(deltaTime);
            checkCollisions();

            // Level up after destroying 5 large asteroids
            if (largeAsteroidsDestroyed >= 5) {
                player.level++;
                largeAsteroidsDestroyed = 0; // Reset counter
                enemySpawnRate *= 0.9; // Enemies spawn faster
                enemySizeMultiplier += 0.1; // Enemies get larger

                // Reset player's weapon
                player.firepower = initialPlayerState.firepower;
                player.projectileSize = initialPlayerState.projectileSize;
                // player.fireRate = initialPlayerState.fireRate; // Removed to maintain fire rate from slider

                clearEnemies();
                showLevelMessage(player.level);
                updateLevelDisplay();
                updateLevelSettings();
                updateUI();
            }
        }

        // Handle input
        function handleInput(deltaTime) {
            var baseMoveSpeed = 400; // Base movement speed

            // Keyboard controls
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.x -= baseMoveSpeed * deltaTime;
                player.angle = Math.PI; // Left
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.x += baseMoveSpeed * deltaTime;
                player.angle = 0; // Right
            }
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.y -= baseMoveSpeed * deltaTime;
                player.angle = -Math.PI / 2; // Up
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.y += baseMoveSpeed * deltaTime;
                player.angle = Math.PI / 2; // Down
            }
            if (keys['Space'] && !autofire) {
                shoot(false); // Pass false to indicate manual shooting
            }

            // Left joystick controls movement
            if (leftJoystick.active) {
                var dx = leftJoystick.x;
                var dy = leftJoystick.y;

                var distance = Math.sqrt(dx * dx + dy * dy);
                var maxDistance = 100;

                if (distance > 0) {
                    var normalizedDistance = distance / maxDistance;
                    var speedFactor = Math.pow(normalizedDistance, 2); // Less sensitive near center

                    var moveSpeed = baseMoveSpeed * speedFactor;

                    // Apply movement
                    player.x += (dx / distance) * moveSpeed * deltaTime;
                    player.y += (dy / distance) * moveSpeed * deltaTime;

                    // Set player angle for movement direction
                    player.angle = Math.atan2(dy, dx);
                }
            }

            // Right joystick controls shooting direction
            if (rightJoystick.active) {
                var dx = rightJoystick.x;
                var dy = rightJoystick.y;

                var distance = Math.sqrt(dx * dx + dy * dy);
                var maxDistance = 100;

                if (distance > 0) {
                    // Set player shooting angle
                    player.shootAngle = Math.atan2(dy, dx);

                    // Shoot if not autofire
                    if (!autofire) {
                        shoot(false); // Pass false to indicate manual shooting
                    }
                }
            }

            // Mouse controls for shooting if not autofire
            if (mouse.leftDown && !autofire) {
                shoot(false); // Pass false to indicate manual shooting
            }

            // Wrap around screen
            if (player.x < 0) player.x += canvas.width;
            if (player.x > canvas.width) player.x -= canvas.width;
            if (player.y < 0) player.y += canvas.height;
            if (player.y > canvas.height) player.y -= canvas.height;
        }

        // Shoot function
        // Parameter 'isAutofire' indicates if the shoot is triggered by autofire
        function shoot(isAutofire) {
            var now = Date.now();
            if (!isAutofire && (now - player.lastShotTime < player.fireRate)) {
                return; // Prevent manual shooting if fireRate hasn't elapsed
            }

            player.lastShotTime = now;

            var maxFirepower = 20; // Maximum firepower level
            var numProjectiles = Math.min(player.firepower, 10); // Increase projectiles directly with firepower
            numProjectiles = Math.max(numProjectiles, 1); // Ensure at least 1 projectile

            var maxSpreadAngle = Math.PI / 4; // Maximum spread angle (45 degrees)
            var spreadAngle = (player.firepower - 1) * (maxSpreadAngle / (maxFirepower - 1));
            spreadAngle = Math.min(spreadAngle, maxSpreadAngle);

            var startAngle = player.shootAngle - spreadAngle / 2;
            var angleIncrement = numProjectiles > 1 ? spreadAngle / (numProjectiles - 1) : 0;

            for (var i = 0; i < numProjectiles; i++) {
                var angle = startAngle + i * angleIncrement;
                var projectileSpeed = 500 + player.firepower * 5; // Slightly increase speed with firepower
                projectiles.push({
                    x: player.x,
                    y: player.y,
                    angle: angle,
                    size: player.projectileSize,
                    speed: projectileSpeed
                });
            }

            // Play shooting sound or effect here if needed
        }

        // Update projectiles
        function updateProjectiles(deltaTime) {
            for (var i = projectiles.length - 1; i >= 0; i--) {
                var p = projectiles[i];
                p.x += Math.cos(p.angle) * p.speed * deltaTime;
                p.y += Math.sin(p.angle) * p.speed * deltaTime;

                // Remove projectiles that are off-screen
                if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                }
            }
        }

        // Update enemies
        function updateEnemies(deltaTime) {
            var now = Date.now();
            if (now - lastEnemySpawnTime > enemySpawnRate) {
                lastEnemySpawnTime = now;
                spawnEnemy();
            }

            for (var i = enemies.length - 1; i >= 0; i--) {
                var e = enemies[i];

                // Handle enemy fade out
                if (e.fadingOut) {
                    e.opacity -= deltaTime;
                    if (e.opacity <= 0) {
                        enemies.splice(i, 1);
                        continue;
                    }
                } else if (e.state === 'exploding') {
                    e.hitDuration += deltaTime;
                    if (e.hitDuration >= 0.3) {
                        // After duration, split into dizzy faces
                        enemies.splice(i, 1);
                        // Angry face shows WOW emoji before splitting
                        createDizzyFaces(e.x, e.y, e.originalSize / 2);
                        continue;
                    }
                    // Enlarge the size slightly during 'exploding' state
                    e.size = e.originalSize * 1.5;
                } else {
                    // Update enemy position
                    e.x += e.vx * deltaTime;
                    e.y += e.vy * deltaTime;

                    // Only angry faces seek the player
                    if (e.type === 'angry') {
                        // Update enemy velocity to seek the player
                        var dx = player.x - e.x;
                        var dy = player.y - e.y;
                        var angleToPlayer = Math.atan2(dy, dx);

                        // Adjust velocity to move towards the player
                        var speed = e.speed;
                        e.vx = Math.cos(angleToPlayer) * speed;
                        e.vy = Math.sin(angleToPlayer) * speed;
                    }

                    // Handle vibration effect
                    if (e.vibrate) {
                        e.vibrateTimer += deltaTime;
                        var vibrateAmount = Math.sin(e.vibrateTimer * 50) * 5;
                        e.vibrateOffsetX = vibrateAmount;
                        e.vibrateOffsetY = -vibrateAmount;
                        if (e.vibrateTimer >= 0.2) {
                            e.vibrate = false;
                            e.vibrateOffsetX = 0;
                            e.vibrateOffsetY = 0;
                        }
                    }

                    // Update dizzy faces with wavy paths
                    if (e.type === 'dizzy') {
                        e.waveTimer += deltaTime;
                        e.x += Math.cos(e.waveTimer * e.waveFrequency) * e.waveAmplitude * deltaTime;
                        e.y += Math.sin(e.waveTimer * e.waveFrequency) * e.waveAmplitude * deltaTime;
                    }
                }

                // Handle heart-eye emoji fade out
                if (e.type === 'heart') {
                    e.lifeTime += deltaTime;
                    if (e.lifeTime >= 2 && !e.fading) {
                        e.fading = true;
                        e.blinkTimer = 0;
                    }

                    if (e.fading) {
                        e.blinkTimer += deltaTime;
                        e.opacity -= deltaTime / 3; // Fade out over 3 seconds
                        if (e.blinkTimer >= 0.05) { // Faster blinking
                            e.visible = !e.visible;
                            e.blinkTimer = 0;
                        }
                        if (e.lifeTime >= 5 || e.opacity <= 0) {
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                }

                // Wrap around screen
                if (e.x < -e.size) e.x += canvas.width + e.size;
                if (e.x > canvas.width + e.size) e.x -= canvas.width + e.size;
                if (e.y < -e.size) e.y += canvas.height + e.size;
                if (e.y > canvas.height + e.size) e.y -= canvas.height + e.size;
            }
        }

        // Spawn enemy off-screen
        function spawnEnemy() {
            var size = 150 * enemySizeMultiplier; // Increased size each level
            var speed = (50 + 10 * player.level); // Enemies get faster each level

            // Randomly select a side to spawn from
            var side = Math.floor(Math.random() * 4); // 0: left, 1: top, 2: right, 3: bottom
            var x, y, angle;

            if (side === 0) { // Left
                x = -size;
                y = Math.random() * canvas.height;
            } else if (side === 1) { // Top
                x = Math.random() * canvas.width;
                y = -size;
            } else if (side === 2) { // Right
                x = canvas.width + size;
                y = Math.random() * canvas.height;
            } else if (side === 3) { // Bottom
                x = Math.random() * canvas.width;
                y = canvas.height + size;
            }

            // Set angle towards the player
            var dx = player.x - x;
            var dy = player.y - y;
            angle = Math.atan2(dy, dx);

            var vx = Math.cos(angle) * speed;
            var vy = Math.sin(angle) * speed;

            enemies.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                speed: speed,
                size: size,
                originalSize: size,
                type: 'angry',
                state: 'normal',
                hitDuration: 0,
                lifeTime: 0,
                fading: false,
                blinkTimer: 0,
                visible: true,
                opacity: 1,
                hitPoints: 3, // Angry face requires 3 hits
                vibrate: false,
                vibrateTimer: 0,
                vibrateOffsetX: 0,
                vibrateOffsetY: 0
            });
        }

        // Create dizzy faces after angry face explodes
        function createDizzyFaces(x, y, size) {
            for (var k = 0; k < 4; k++) {
                var angle = Math.random() * Math.PI * 2;
                var speed = 150; // Speed for dizzy faces
                var waveFrequency = Math.random() * 5 + 2; // Random frequency
                var waveAmplitude = Math.random() * 50 + 20; // Random amplitude
                enemies.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    speed: speed,
                    size: size,
                    originalSize: size,
                    type: 'dizzy',
                    state: 'normal',
                    hitDuration: 0,
                    lifeTime: 0,
                    fading: false,
                    blinkTimer: 0,
                    visible: true,
                    opacity: 1,
                    hitPoints: 2, // Dizzy faces require 2 hits
                    vibrate: false,
                    vibrateTimer: 0,
                    vibrateOffsetX: 0,
                    vibrateOffsetY: 0,
                    waveTimer: 0,
                    waveFrequency: waveFrequency,
                    waveAmplitude: waveAmplitude
                });
            }
        }

        // Clear enemies when leveling up or changing level
        function clearEnemies() {
            // Fade out and remove all enemies
            enemies.forEach(function(e) {
                e.fadingOut = true;
            });
        }

        // Show level message
        function showLevelMessage(level) {
            var levelMessage = document.createElement('div');
            levelMessage.className = 'levelMessage';
            levelMessage.innerText = 'level ' + level;
            document.body.appendChild(levelMessage);

            // Fade in
            setTimeout(function() {
                levelMessage.style.opacity = '1';
            }, 50);

            // Fade out after 1 second
            setTimeout(function() {
                levelMessage.style.opacity = '0';
                // Remove after fade out
                setTimeout(function() {
                    document.body.removeChild(levelMessage);
                }, 1000);
            }, 1500);
        }

        // Check collisions
        function checkCollisions() {
            // Check projectile-enemy collisions
            for (var i = projectiles.length - 1; i >= 0; i--) {
                var p = projectiles[i];
                for (var j = enemies.length - 1; j >= 0; j--) {
                    var e = enemies[j];
                    var dx = p.x - e.x;
                    var dy = p.y - e.y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    var collisionDistance = (p.size / 2) + (e.size / 2) * 0.9;

                    if (distance < collisionDistance) {
                        projectiles.splice(i, 1);

                        e.hitPoints--;

                        // Start vibration
                        e.vibrate = true;
                        e.vibrateTimer = 0;

                        if (e.type === 'angry') {
                            // Grow slightly with each hit
                            e.size += e.originalSize * 0.05;
                        }

                        // Play bonk sound
                        playBonkSound();

                        if (e.hitPoints <= 0) {
                            if (e.type === 'angry' && e.state === 'normal') {
                                // Change to 'exploding' state and display WOW emoji
                                e.state = 'exploding';
                                e.hitDuration = 0;
                                e.type = 'wow'; // Temporarily set to wow for rendering
                                largeAsteroidsDestroyed++;
                                player.score += 5;
                                updateUI();
                            } else if (e.type === 'dizzy' && e.state === 'normal') {
                                // Transform into heart-eyed face
                                e.type = 'heart';
                                e.state = 'normal';
                                e.hitPoints = 3; // Heart-eyed faces require 3 hits
                                e.lifeTime = 0;
                                e.fading = false;
                                e.visible = true;
                                e.opacity = 1;
                                player.score += 2;
                                updateUI();
                            } else if (e.type === 'heart' && e.state === 'normal') {
                                // Remove heart-eyed face after 3 hits
                                enemies.splice(j, 1);
                                player.score += 1;
                                updateUI();
                            }
                        }
                        break;
                    }
                }
            }

            // Check player-enemy collisions
            for (var i = enemies.length - 1; i >= 0; i--) {
                var e = enemies[i];
                var dx = player.x - e.x;
                var dy = player.y - e.y;
                var distance = Math.sqrt(dx * dx + dy * dy);

                var heartSize = player.size;
                if (isMobileDevice()) {
                    heartSize = player.size * 1.5; // Slightly larger on mobile
                }

                var collisionDistance = (heartSize / 2) + (e.size / 2) * 0.9;

                if (distance < collisionDistance) {
                    if (e.type === 'heart') {
                        // Collect heart-eyed face
                        enemies.splice(i, 1);
                        player.score += 1;
                        player.projectileSize += 1;
                        player.firepower += 1; // Increase firepower
                        updateUI();
                    } else if (e.state !== 'exploding') {
                        // Game over
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                        document.getElementById('restartButton').style.display = 'block';
                    }
                }
            }
        }

        // Render function
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle + Math.PI / 2); // Rotate to pointy end forward

            var heartSize = player.size;
            if (isMobileDevice()) {
                heartSize = player.size * 1.5; // Slightly larger on mobile
            }

            ctx.font = heartSize + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🩷', 0, 0); // Use pink heart emoji
            ctx.restore();

            // Draw projectiles
            for (var i = 0; i < projectiles.length; i++) {
                var p = projectiles[i];
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle + Math.PI / 2);
                ctx.font = p.size + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('💖', 0, 0); // Heart bullets
                ctx.restore();
            }

            // Draw enemies
            for (var i = 0; i < enemies.length; i++) {
                var e = enemies[i];
                if (e.visible) {
                    ctx.save();
                    ctx.translate(e.x + (e.vibrateOffsetX || 0), e.y + (e.vibrateOffsetY || 0));
                    ctx.font = e.size + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    var emoji = '';
                    if (e.type === 'angry') {
                        emoji = '😠';
                    } else if (e.type === 'dizzy') {
                        emoji = '😵‍💫';
                    } else if (e.type === 'heart') {
                        emoji = '😍';
                    } else if (e.type === 'wow') {
                        emoji = '😮';
                    }

                    ctx.globalAlpha = e.opacity !== undefined ? e.opacity : 1;

                    ctx.fillText(emoji, 0, 0);
                    ctx.restore();
                    ctx.globalAlpha = 1; // Reset alpha
                }
            }
        }

        // Check if device is mobile
        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }

        // Update UI elements
        function updateUI() {
            document.querySelector('#scoreboard .score').innerText = 'score: ' + player.score;
            document.querySelector('#scoreboard .level').innerText = 'level: ' + player.level;
        }

        // Start the game
        function startGame() {
            gameStarted = true;
            gameOver = false;
            player.score = 0;
            player.level = 1;
            largeAsteroidsDestroyed = 0;
            autofire = false;
            autofireCheckbox.checked = false;
            stopAutofire();

            // Reset player's weapon
            player.firepower = initialPlayerState.firepower;
            player.projectileSize = initialPlayerState.projectileSize;
            player.fireRate = 1000 / firingSpeed; // Reset fire rate based on slider

            enemySpawnRate = 2000;
            enemySizeMultiplier = 1; // Reset enemy size multiplier
            enemies = [];
            projectiles = [];
            updateUI();
            updateLevelDisplay();
            updateLevelSettings();
            lastTime = performance.now();
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            isPaused = false;
            gameLoopRequest = requestAnimationFrame(gameLoop);
        }

        // Restart the game
        function restartGame() {
            gameOver = false;
            player.score = 0;
            largeAsteroidsDestroyed = 0;
            autofire = false;
            autofireCheckbox.checked = false;
            stopAutofire();

            // Note: Do NOT reset player.level here to maintain the current level
            // player.level = 1; // Removed to retain current level

            // Reset player's weapon
            player.firepower = initialPlayerState.firepower;
            player.projectileSize = initialPlayerState.projectileSize;
            player.fireRate = 1000 / firingSpeed; // Reset fire rate based on slider

            // Recalculate enemy parameters based on current level
            updateLevelSettings();

            enemies = [];
            projectiles = [];
            updateUI();
            // No need to update level display as level remains the same
            clearEnemies();
            lastTime = performance.now();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            isPaused = false;
            gameLoopRequest = requestAnimationFrame(gameLoop);
        }

        // Pause the game
        function pauseGame() {
            isPaused = true;
            cancelAnimationFrame(gameLoopRequest);
            if (autofire) {
                stopAutofire();
            }
        }

        // Resume the game
        function resumeGame() {
            if (!gameOver && gameStarted && !levelChanged) {
                isPaused = false;
                lastTime = performance.now();
                gameLoopRequest = requestAnimationFrame(gameLoop);
                if (autofire) {
                    startAutofire();
                }
            }
        }

        // Update Level Display in Menu
        function updateLevelDisplay() {
            levelDisplay.innerText = player.level;
        }

        // Update Level Settings based on current level
        function updateLevelSettings() {
            enemySpawnRate = 2000 / player.level; // Example: faster spawn with higher levels
            enemySizeMultiplier = 1 + (player.level - 1) * 0.1; // Example: larger enemies with higher levels
        }

        // Autofire Functions continued...
        // (Already implemented above)

        // Initial Level Settings
        updateLevelDisplay();
        updateLevelSettings();

        // Main game loop (repeated to ensure functionality)
        function gameLoop(timestamp) {
            if (!gameStarted || gameOver || isPaused) return;

            var deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;

            update(deltaTime);
            render();

            gameLoopRequest = requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>Space Haters</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Scoreboard Styles */
        #scoreboard {
            position: absolute;
            top: 5%;
            left: 5%;
            color: magenta;
            font-family: 'Press Start 2P', cursive;
            font-size: 3vh;
            user-select: none;
            z-index: 10;
            text-align: left;
        }

        #scoreboard .title {
            font-size: 4vh;
            margin-bottom: 10px;
        }

        #scoreboard .score {
            font-size: 2.5vh;
        }

        /* Game Over and Restart Button Styles */
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 6vh;
            color: magenta;
            display: none;
            z-index: 15;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
        }

        #restartButton {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 15px 30px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
            display: none;
        }

        #restartButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Start Button Styles */
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: magenta;
            padding: 20px 40px;
            border: 3px solid magenta;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            user-select: none;
            z-index: 15;
        }

        #startButton:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Media Query for Mobile Devices */
        @media only screen and (max-width: 768px) {
            #scoreboard .title {
                font-size: 3vh;
            }

            #scoreboard .score {
                font-size: 2vh;
            }

            #gameOver {
                font-size: 4vh;
            }

            #startButton, #restartButton {
                font-size: 1.5rem;
                padding: 10px 20px;
            }
        }
    </style>
    <!-- Include the Press Start 2P font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Scoreboard -->
    <div id="scoreboard">
        <div class="title">Space Haters</div>
        <div class="score">Score: 0</div>
        <div class="level">Level: 1</div>
    </div>
    <!-- Game Over and Restart Button -->
    <div id="gameOver">GAME OVER</div>
    <div id="restartButton">Restart</div>
    <!-- Start Button -->
    <div id="startButton">Start Game</div>
    <!-- Background Canvas -->
    <canvas id="backgroundCanvas"></canvas>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <script>
        // Initialize variables
        var gameStarted = false;
        var gameOver = false;

        // Get the canvases and contexts
        var backgroundCanvas = document.getElementById('backgroundCanvas');
        var bgCtx = backgroundCanvas.getContext('2d');

        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        // Resize canvases to fit the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            initStars(); // Reinitialize stars on resize
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Starfield variables
        var stars = [];
        var numStars = 200;

        function initStars() {
            stars = [];
            for (var i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * backgroundCanvas.width,
                    y: Math.random() * backgroundCanvas.height,
                    z: Math.random() * backgroundCanvas.width
                });
            }
        }

        function moveStars() {
            for (var i = 0; i < stars.length; i++) {
                stars[i].z -= 2;
                if (stars[i].z <= 0) {
                    stars[i].x = Math.random() * backgroundCanvas.width;
                    stars[i].y = Math.random() * backgroundCanvas.height;
                    stars[i].z = backgroundCanvas.width;
                }
            }
        }

        function drawStars() {
            bgCtx.fillStyle = 'black';
            bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            bgCtx.fillStyle = 'white';
            for (var i = 0; i < stars.length; i++) {
                var k = 128.0 / stars[i].z;
                var x = (stars[i].x - backgroundCanvas.width / 2) * k + backgroundCanvas.width / 2;
                var y = (stars[i].y - backgroundCanvas.height / 2) * k + backgroundCanvas.height / 2;
                if (x >= 0 && x <= backgroundCanvas.width && y >= 0 && y <= backgroundCanvas.height) {
                    var size = (1 - stars[i].z / backgroundCanvas.width) * 2;
                    bgCtx.fillRect(x, y, size, size);
                }
            }
        }

        function animateBackground() {
            moveStars();
            drawStars();
            requestAnimationFrame(animateBackground);
        }

        initStars();
        animateBackground();

        // Game variables
        var player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            rotation: 0,
            score: 0,
            level: 1,
            fireRate: 300, // milliseconds between shots
            lastShotTime: 0,
            projectileSize: 20,
            size: 60, // Increased size
            firepower: 1 // Number of heart-eye faces collected
        };

        var projectiles = [];
        var enemies = [];
        var keys = {};
        var mouse = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            leftDown: false
        };

        var touch = {
            x: 0,
            y: 0,
            active: false
        };

        var lastTime = 0;
        var enemySpawnRate = 2000; // milliseconds between spawns
        var lastEnemySpawnTime = 0;

        // Event listeners for controls
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', function(e) {
            keys[e.code] = false;
        });

        // Mouse controls
        canvas.addEventListener('mousemove', function(e) {
            var rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', function(e) {
            e.preventDefault();
            if (e.button === 0) {
                mouse.leftDown = true;
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            e.preventDefault();
            if (e.button === 0) {
                mouse.leftDown = false;
            }
        });

        // Touch controls
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            var rect = canvas.getBoundingClientRect();
            touch.x = e.touches[0].clientX - rect.left;
            touch.y = e.touches[0].clientY - rect.top;
            touch.active = true;
        });

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            var rect = canvas.getBoundingClientRect();
            touch.x = e.touches[0].clientX - rect.left;
            touch.y = e.touches[0].clientY - rect.top;
        });

        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            touch.active = false;
        });

        // Start and Restart buttons
        var startButton = document.getElementById('startButton');
        var restartButton = document.getElementById('restartButton');

        startButton.addEventListener('click', function() {
            startGame();
        });

        restartButton.addEventListener('click', function() {
            restartGame();
        });

        // Main game loop
        function gameLoop(timestamp) {
            if (!gameStarted || gameOver) return;

            var deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;

            update(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        // Update function
        function update(deltaTime) {
            handleInput(deltaTime);
            updateProjectiles(deltaTime);
            updateEnemies(deltaTime);
            checkCollisions();

            // Increase level every 50 points
            if (player.score >= player.level * 50) {
                player.level++;
                enemySpawnRate *= 0.9; // Enemies spawn faster
                updateUI();
            }
        }

        // Handle input
        function handleInput(deltaTime) {
            // Keyboard controls
            if (keys['ArrowLeft']) {
                player.angle -= 2 * deltaTime; // Rotate at 2 radians per second
            }
            if (keys['ArrowRight']) {
                player.angle += 2 * deltaTime;
            }

            if (keys['ArrowUp']) {
                player.speed += 200 * deltaTime; // Increase speed
            }
            if (keys['ArrowDown']) {
                player.speed -= 200 * deltaTime; // Decrease speed
            }

            if (keys['Space']) {
                shoot();
            }

            // Touch controls
            if (touch.active) {
                // Touchscreen controls
                var offset = -400; // Negative offset to position the ship behind the finger

                // Calculate the angle from the ship to the touch point
                var dx = touch.x - player.x;
                var dy = touch.y - player.y;
                var angleToTouch = Math.atan2(dy, dx);

                // Desired position is behind the touch point by offset pixels
                var desiredX = touch.x + Math.cos(angleToTouch) * offset;
                var desiredY = touch.y + Math.sin(angleToTouch) * offset;

                // Smoothly move the player towards the desired position
                var smoothingFactor = 0.1; // Adjust between 0 (no movement) and 1 (instant movement)
                player.x += (desiredX - player.x) * smoothingFactor;
                player.y += (desiredY - player.y) * smoothingFactor;

                // Set the player's angle towards the touch point
                player.angle = angleToTouch;

                shoot();
            } else if (mouse.leftDown) {
                // Mouse controls
                var dx = mouse.x - player.x;
                var dy = mouse.y - player.y;
                var angleToMouse = Math.atan2(dy, dx);

                // Desired position is behind the mouse cursor by desiredDistance pixels
                var desiredDistance = 50;
                var desiredX = mouse.x - Math.cos(angleToMouse) * desiredDistance;
                var desiredY = mouse.y - Math.sin(angleToMouse) * desiredDistance;

                // Smoothly move the player towards the desired position
                var smoothingFactor = 0.1;
                player.x += (desiredX - player.x) * smoothingFactor;
                player.y += (desiredY - player.y) * smoothingFactor;

                // Set player angle towards the mouse cursor
                player.angle = angleToMouse;

                shoot();
            } else {
                // No input; keep the ship in its current position
                // Optionally, apply friction or slow down the ship
                player.speed *= 0.98; // Apply friction to gradually slow down the ship
            }

            // Update player position based on speed and angle (for keyboard movement)
            if (keys['ArrowUp'] || keys['ArrowDown']) {
                player.x += Math.cos(player.angle) * player.speed * deltaTime;
                player.y += Math.sin(player.angle) * player.speed * deltaTime;

                // Apply friction
                player.speed *= 0.99;
            }

            // Wrap around screen
            if (player.x < 0) player.x += canvas.width;
            if (player.x > canvas.width) player.x -= canvas.width;
            if (player.y < 0) player.y += canvas.height;
            if (player.y > canvas.height) player.y -= canvas.height;
        }

        // Shoot function
        function shoot() {
            var now = Date.now();
            if (now - player.lastShotTime > player.fireRate) {
                player.lastShotTime = now;

                var maxFirepower = 20; // Maximum firepower level
                var numProjectiles = 1 + Math.floor((player.firepower - 1) / 2); // Increase projectiles every 2 firepower
                numProjectiles = Math.min(numProjectiles, 10); // Cap the maximum number of projectiles

                var maxSpreadAngle = Math.PI / 4; // Maximum spread angle (45 degrees)
                var spreadAngle = (player.firepower / maxFirepower) * maxSpreadAngle;
                spreadAngle = Math.min(spreadAngle, maxSpreadAngle);

                var startAngle = player.angle - spreadAngle / 2;
                var angleIncrement = numProjectiles > 1 ? spreadAngle / (numProjectiles - 1) : 0;

                for (var i = 0; i < numProjectiles; i++) {
                    var angle = startAngle + i * angleIncrement;
                    var projectileSpeed = 500 + player.firepower * 5; // Slightly increase speed with firepower
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        angle: angle,
                        size: player.projectileSize,
                        speed: projectileSpeed
                    });
                }

                // Decrease fire rate with increased firepower
                player.fireRate = 300 * Math.pow(0.95, player.firepower - 1);
                player.fireRate = Math.max(player.fireRate, 50); // Minimum fire rate cap
            }
        }

        // Update projectiles
        function updateProjectiles(deltaTime) {
            for (var i = projectiles.length - 1; i >= 0; i--) {
                var p = projectiles[i];
                p.x += Math.cos(p.angle) * p.speed * deltaTime;
                p.y += Math.sin(p.angle) * p.speed * deltaTime;

                // Remove projectiles that are off-screen
                if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                }
            }
        }

        // Update enemies
        function updateEnemies(deltaTime) {
            var now = Date.now();
            if (now - lastEnemySpawnTime > enemySpawnRate) {
                lastEnemySpawnTime = now;
                spawnEnemy();
            }

            for (var i = enemies.length - 1; i >= 0; i--) {
                var e = enemies[i];

                // Handle hit animation for 'wow' state
                if (e.state === 'hit') {
                    e.hitDuration += deltaTime;
                    if (e.hitDuration >= 0.5) {
                        // After 0.5 seconds, split into confused faces
                        enemies.splice(i, 1);
                        // Angry face splits into 4 confused faces
                        for (var k = 0; k < 4; k++) {
                            var angle = Math.random() * Math.PI * 2;
                            enemies.push({
                                x: e.x,
                                y: e.y,
                                vx: Math.cos(angle) * 100,
                                vy: Math.sin(angle) * 100,
                                size: e.originalSize / 2,
                                originalSize: e.originalSize / 2,
                                type: 'confused',
                                state: 'normal',
                                hitDuration: 0,
                                lifeTime: 0, // For heart-eye emojis
                                fading: false,
                                blinkTimer: 0,
                                visible: true,
                                opacity: 1
                            });
                        }
                        continue;
                    }
                    // Enlarge the size slightly during 'wow' state
                    e.size = e.originalSize * 1.2;
                } else {
                    // Update enemy velocity to seek the player
                    var dx = player.x - e.x;
                    var dy = player.y - e.y;
                    var angleToPlayer = Math.atan2(dy, dx);

                    // Adjust velocity to move towards the player
                    var speed = e.speed;
                    e.vx = Math.cos(angleToPlayer) * speed;
                    e.vy = Math.sin(angleToPlayer) * speed;

                    e.x += e.vx * deltaTime;
                    e.y += e.vy * deltaTime;
                }

                // Handle heart-eye emoji fade out
                if (e.type === 'heart') {
                    e.lifeTime += deltaTime;
                    if (e.lifeTime >= 2 && !e.fading) {
                        e.fading = true;
                        e.blinkTimer = 0;
                    }

                    if (e.fading) {
                        e.blinkTimer += deltaTime;
                        e.opacity -= deltaTime / 3; // Fade out over 3 seconds
                        if (e.blinkTimer >= 0.3) {
                            e.visible = !e.visible;
                            e.blinkTimer = 0;
                        }
                        if (e.lifeTime >= 5 || e.opacity <= 0) {
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                }

                // Wrap around screen
                if (e.x < -e.size) e.x += canvas.width + e.size;
                if (e.x > canvas.width + e.size) e.x -= canvas.width + e.size;
                if (e.y < -e.size) e.y += canvas.height + e.size;
                if (e.y > canvas.height + e.size) e.y -= canvas.height + e.size;
            }
        }

        // Spawn enemy off-screen
        function spawnEnemy() {
            var size = 150; // Increased size for angry faces
            var speed = (50 + 10 * player.level); // Enemies get faster each level

            // Randomly select a side to spawn from
            var side = Math.floor(Math.random() * 4); // 0: left, 1: top, 2: right, 3: bottom
            var x, y;

            if (side === 0) { // Left
                x = -size;
                y = Math.random() * canvas.height;
            } else if (side === 1) { // Top
                x = Math.random() * canvas.width;
                y = -size;
            } else if (side === 2) { // Right
                x = canvas.width + size;
                y = Math.random() * canvas.height;
            } else if (side === 3) { // Bottom
                x = Math.random() * canvas.width;
                y = canvas.height + size;
            }

            // Set initial velocity towards the player
            var dx = player.x - x;
            var dy = player.y - y;
            var angleToPlayer = Math.atan2(dy, dx);
            var vx = Math.cos(angleToPlayer) * speed;
            var vy = Math.sin(angleToPlayer) * speed;

            enemies.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                speed: speed,
                size: size,
                originalSize: size,
                type: 'angry', // 'angry', 'confused', 'heart', 'wow'
                state: 'normal', // 'normal', 'hit'
                hitDuration: 0, // Duration since hit
                lifeTime: 0, // For heart-eye emojis
                fading: false,
                blinkTimer: 0,
                visible: true,
                opacity: 1
            });
        }

        // Check collisions
        function checkCollisions() {
            // Check projectile-enemy collisions
            for (var i = projectiles.length - 1; i >= 0; i--) {
                var p = projectiles[i];
                for (var j = enemies.length - 1; j >= 0; j--) {
                    var e = enemies[j];
                    var dx = p.x - e.x;
                    var dy = p.y - e.y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < (p.size / 2) + (e.size / 2) * 0.6) {
                        projectiles.splice(i, 1);

                        if (e.type === 'angry' && e.state === 'normal') {
                            // Change to 'wow' state
                            e.type = 'wow';
                            e.state = 'hit';
                            e.hitDuration = 0;
                            player.score += 5;
                            updateUI();
                        } else if (e.type === 'confused') {
                            // Confused face turns into heart-eye face
                            e.type = 'heart';
                            e.lifeTime = 0;
                            e.fading = false;
                            e.visible = true;
                            e.opacity = 1;
                            player.score += 2;
                            updateUI();
                        }

                        break;
                    }
                }
            }

            // Check player-enemy collisions
            for (var i = enemies.length - 1; i >= 0; i--) {
                var e = enemies[i];
                var dx = player.x - e.x;
                var dy = player.y - e.y;
                var distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < (player.size / 2) + (e.size / 2) * 0.6) {
                    if (e.type === 'heart') {
                        // Collect heart-eye face
                        enemies.splice(i, 1);
                        player.score += 1;
                        player.projectileSize += 1;
                        player.firepower += 1; // Increase firepower
                        updateUI();
                    } else if (e.type !== 'wow') {
                        // Game over
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                        document.getElementById('restartButton').style.display = 'block';
                    }
                }
            }
        }

        // Render function
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle + Math.PI / 2); // Rotate to pointy end forward
            ctx.font = player.size + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('❤️', 0, 0);
            ctx.restore();

            // Draw projectiles
            for (var i = 0; i < projectiles.length; i++) {
                var p = projectiles[i];
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle + Math.PI / 2);
                ctx.font = p.size + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('💖', 0, 0);
                ctx.restore();
            }

            // Draw enemies
            for (var i = 0; i < enemies.length; i++) {
                var e = enemies[i];
                if (e.visible) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.font = e.size + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    var emoji = '';
                    if (e.type === 'angry') {
                        emoji = '😠';
                    } else if (e.type === 'confused') {
                        emoji = '😕';
                    } else if (e.type === 'heart') {
                        emoji = '😍';
                    } else if (e.type === 'wow') {
                        emoji = '😮';
                    }

                    if (e.type === 'heart' && e.fading) {
                        ctx.globalAlpha = e.opacity;
                    }

                    ctx.fillText(emoji, 0, 0);
                    ctx.restore();
                    ctx.globalAlpha = 1; // Reset alpha
                }
            }
        }

        // Update UI elements
        function updateUI() {
            document.querySelector('#scoreboard .score').innerText = 'Score: ' + player.score;
            document.querySelector('#scoreboard .level').innerText = 'Level: ' + player.level;
        }

        // Start the game
        function startGame() {
            gameStarted = true;
            gameOver = false;
            player.score = 0;
            player.level = 1;
            player.fireRate = 300;
            player.projectileSize = 20;
            player.firepower = 1; // Reset firepower
            enemySpawnRate = 2000;
            enemies = [];
            projectiles = [];
            updateUI();
            lastTime = performance.now();
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            requestAnimationFrame(gameLoop);
        }

        // Restart the game
        function restartGame() {
            gameOver = false;
            player.score = 0;
            player.level = 1;
            player.fireRate = 300;
            player.projectileSize = 20;
            player.firepower = 1; // Reset firepower
            enemySpawnRate = 2000;
            enemies = [];
            projectiles = [];
            updateUI();
            lastTime = performance.now();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>

